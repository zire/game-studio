<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pacman - Random Maze</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body { 
      background: #000; 
      margin: 0; 
      padding: 0;
      display: flex; 
      align-items: center; 
      justify-content: center; 
      min-height: 100vh;
      height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    
    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
      padding: 10px;
      width: 100%;
      max-width: 400px;
      height: 100vh;
      box-sizing: border-box;
    }
    
    canvas { 
      border: 2px solid #fff; 
      background: #111; 
      display: block; 
      margin: 0 auto;
      max-width: 100%;
      max-height: 70vh;
    }
    
    #newGameBtn {
      font-size: 1.1em;
      padding: 10px 20px;
      background: #222;
      color: #FFD700;
      border: 2px solid #FFD700;
      border-radius: 8px;
      cursor: pointer;
      font-family: monospace;
      transition: all 0.3s ease;
    }
    
    #newGameBtn:hover {
      background: #FFD700;
      color: #222;
    }
    
    .level-info {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 400px;
      margin-bottom: 10px;
      font-family: monospace;
      font-size: 1.1em;
      color: #FFD700;
    }
    
    #levelDisplay, #livesDisplay {
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 5px;
      border: 1px solid #FFD700;
    }
    
    #message {
      color: yellow;
      font-family: monospace;
      font-size: 1.5em;
      text-shadow: 2px 2px 8px #000;
      text-align: center;
      min-height: 40px;
    }
    
    /* Mobile Controls */
    .mobile-controls {
      display: none;
      flex-direction: column;
      gap: 8px;
      margin-top: 20px;
    }
    
    .control-row {
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    
    .control-row.middle {
      gap: 40px;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(255, 215, 0, 0.2);
      border: 2px solid #FFD700;
      border-radius: 50%;
      color: #FFD700;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      margin: 5px;
    }
    
    .control-btn:active {
      background: rgba(255, 215, 0, 0.5);
      transform: scale(0.95);
    }
    
    .control-btn.up { font-size: 18px; }
    .control-btn.down { font-size: 18px; }
    .control-btn.left { font-size: 18px; }
    .control-btn.right { font-size: 18px; }
    
    /* Instructions */
    .instructions {
      color: #ccc;
      text-align: center;
      font-size: 12px;
      margin-top: 8px;
      opacity: 0.8;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
      
      .instructions {
        font-size: 11px;
      }
      
      #message {
        font-size: 1.3em;
        min-height: 35px;
      }
      
      #newGameBtn {
        font-size: 1em;
        padding: 8px 16px;
      }
    }
    
    @media (max-width: 480px) {
      .game-container {
        padding: 8px;
        gap: 12px;
      }
      
      .control-btn {
        width: 55px;
        height: 55px;
        font-size: 22px;
        margin: 3px;
      }
      
      .control-row {
        gap: 15px;
      }
      
      .control-row.middle {
        gap: 30px;
      }
      
      .mobile-controls {
        gap: 6px;
      }
      
      #message {
        font-size: 1.1em;
      }
    }
    
    /* Portrait mode optimizations */
    @media (orientation: portrait) {
      .game-container {
        max-width: 350px;
        height: 100vh;
      }
      
      canvas {
        max-height: 60vh;
      }
    }
    
    /* Firefox mobile specific fixes */
    @-moz-document url-prefix() {
      body {
        height: 100vh;
        min-height: 100vh;
      }
      
      .game-container {
        height: 100vh;
        min-height: 100vh;
      }
    }
  </style>
</head>
<body>
      <div class="game-container">
      <div class="level-info">
        <span id="levelDisplay">Level 1</span>
        <span id="livesDisplay">Lives: 5</span>
      </div>
      <button id="newGameBtn">New Game</button>
      <canvas id="game" width="300" height="480"></canvas>
      <div id="message"></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
      <div class="control-row">
        <button class="control-btn up" data-direction="up">↑</button>
      </div>
      <div class="control-row middle">
        <button class="control-btn left" data-direction="left">←</button>
        <button class="control-btn right" data-direction="right">→</button>
      </div>
      <div class="control-row">
        <button class="control-btn down" data-direction="down">↓</button>
      </div>
    </div>
    
    <div class="instructions">
      <div id="desktop-instructions">Use arrow keys to move Pacman to the exit door</div>
      <div id="mobile-instructions" style="display: none;">Tap the arrow buttons to move Pacman to the exit door</div>
    </div>
  </div>

  <script>
    // Portrait-optimized maze dimensions
    const mapWidth = 10;  // Back to original size
    const mapHeight = 16; // Taller for portrait
    
    // Responsive canvas sizing for portrait mode
    function resizeCanvas() {
      const canvas = document.getElementById('game');
      const maxWidth = Math.min(window.innerWidth - 20, 300);
      const maxHeight = Math.min(window.innerHeight * 0.65, 480);
      
      // For portrait mode, prioritize height
      let size;
      if (window.innerHeight > window.innerWidth) {
        // Portrait mode - use height as primary constraint
        size = Math.min(maxHeight / mapHeight, maxWidth / mapWidth);
      } else {
        // Landscape mode - use width as primary constraint
        size = Math.min(maxWidth / mapWidth, maxHeight / mapHeight);
      }
      
      const canvasWidth = mapWidth * size;
      const canvasHeight = mapHeight * size;
      
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // Update tile size based on canvas size
      window.tileSize = size;
    }
    
    // Initialize responsive design
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Show/hide instructions based on device
    function updateInstructions() {
      const isMobile = window.innerWidth <= 768;
      document.getElementById('desktop-instructions').style.display = isMobile ? 'none' : 'block';
      document.getElementById('mobile-instructions').style.display = isMobile ? 'block' : 'none';
    }
    updateInstructions();
    window.addEventListener('resize', updateInstructions);

    // Load waka-waka sound effect
    const wakaSound = new Audio('waka.wav');
    wakaSound.volume = 0.5;

    function generateRandomMap() {
      // Maze generation using randomized DFS
      const newMap = [];
      for (let y = 0; y < mapHeight; y++) {
        const row = [];
        for (let x = 0; x < mapWidth; x++) {
          row.push(1); // Start with all walls
        }
        newMap.push(row);
      }

      // Helper to shuffle directions
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      // DFS maze generation (full maze including exit door position)
      function carve(x, y) {
        newMap[y][x] = 0;
        const dirs = [ [0, -2], [0, 2], [-2, 0], [2, 0] ];
        shuffle(dirs);
        for (const [dx, dy] of dirs) {
          const nx = x + dx, ny = y + dy;
          if (ny > 0 && ny < mapHeight-1 && nx > 0 && nx < mapWidth-1 && newMap[ny][nx] === 1) {
            newMap[y + dy/2][x + dx/2] = 0; // Remove wall between
            carve(nx, ny);
          }
        }
      }

      carve(1, 1); // Start maze at (1,1)

      // Optionally open a few more random cells for pellet variety
      let extraOpens = Math.floor((mapWidth * mapHeight) * 0.1);
      while (extraOpens > 0) {
        const rx = 1 + Math.floor(Math.random() * (mapWidth - 2));
        const ry = 1 + Math.floor(Math.random() * (mapHeight - 2));
        if (newMap[ry][rx] === 1) {
          newMap[ry][rx] = 0;
          extraOpens--;
        }
      }

      // Ensure (1,1) is open
      newMap[1][1] = 0;
      
      // Place exit door at bottom-right corner
      newMap[mapHeight - 2][mapWidth - 2] = 2; // Door
      
      // Ensure the door is connected to the maze
      // Create a guaranteed path from the maze to the door
      let doorConnected = false;
      
      // Try to connect from the left of the door
      if (newMap[mapHeight - 2][mapWidth - 3] === 0) {
        doorConnected = true;
      }
      // Try to connect from above the door
      else if (newMap[mapHeight - 3][mapWidth - 2] === 0) {
        doorConnected = true;
      }
      // If not connected, force a connection from the left
      if (!doorConnected) {
        newMap[mapHeight - 2][mapWidth - 3] = 0; // Open the cell to the left of the door
      }
      
      return newMap;
    }

    // Calculate shortest path length using BFS
    function calculateShortestPath(map) {
      const queue = [{x: 1, y: 1, distance: 0}];
      const visited = new Set();
      const targetX = mapWidth - 2;
      const targetY = mapHeight - 2;
      
      while (queue.length > 0) {
        const {x, y, distance} = queue.shift();
        const key = `${x},${y}`;
        
        if (visited.has(key)) continue;
        visited.add(key);
        
        if (x === targetX && y === targetY) {
          return distance;
        }
        
        // Check all 4 directions
        const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
        for (const [dx, dy] of directions) {
          const nx = x + dx;
          const ny = y + dy;
          
          if (ny >= 0 && ny < mapHeight && nx >= 0 && nx < mapWidth && 
              (map[ny][nx] === 0 || map[ny][nx] === 2) && !visited.has(`${nx},${ny}`)) {
            queue.push({x: nx, y: ny, distance: distance + 1});
          }
        }
      }
      
      return Infinity; // No path found
    }

    // Get level parameters based on current level
    function getLevelParameters(level) {
      // Lives: 5 at level 1, 1 at level 100
      const lives = Math.max(1, 5 - Math.floor((level - 1) / 25));
      
      // Ghost count: 0 (1-3), 1 (4-15), 2 (16-30), 3 (31-50), 4 (51-75), 5 (76-100)
      let ghostCount;
      if (level <= 3) ghostCount = 0;
      else if (level <= 15) ghostCount = 1;
      else if (level <= 30) ghostCount = 2;
      else if (level <= 50) ghostCount = 3;
      else if (level <= 75) ghostCount = 4;
      else ghostCount = 5;
      
      // Target path length: shorter paths for higher levels (more difficult)
      const targetPathLength = Math.max(15, 50 - Math.floor((level - 1) / 2));
      
      return { lives, ghostCount, targetPathLength };
    }

    let map, pelletMap, pelletsLeft, pacman;
    let ghosts = [];
    let ghostMoveInterval = null;
    let currentLevel = 1;
    let playerLives = 5;
    let shortestPathLength = 0;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const message = document.getElementById('message');
    const newGameBtn = document.getElementById('newGameBtn');

    function resetGame() {
      // Get level parameters
      const { lives, ghostCount, targetPathLength } = getLevelParameters(currentLevel);
      playerLives = lives;
      
      // Generate maze with appropriate difficulty
      let attempts = 0;
      let generatedMap;
      let pathLength;
      
      do {
        generatedMap = generateRandomMap();
        pathLength = calculateShortestPath(generatedMap);
        attempts++;
      } while (pathLength > targetPathLength + 10 && attempts < 20); // Try to get close to target path length
      
      map = generatedMap;
      shortestPathLength = pathLength;
      
      pelletMap = map.map((row, y) => row.map((cell, x) => {
        // Don't place pellets on the door
        if (cell === 2) return 0;
        return cell === 0 ? 1 : 0;
      }));
      pelletsLeft = pelletMap.flat().reduce((a, b) => a + b, 0);
      pacman = { x: 1, y: 1 };
      
      // Generate ghosts based on level
      ghosts = [];
      const ghostNames = ['Clement', 'Chase', 'Ray', 'Jayden', 'Andrew'];
      const ghostColors = ['#147880', '#60EEE3', '#25BF94', '#E9E12E', '#FF6B41'];
      
      for (let i = 0; i < ghostCount; i++) {
        let x, y;
        do {
          x = 1 + Math.floor(Math.random() * (mapWidth - 3));
          y = 1 + Math.floor(Math.random() * (mapHeight - 3));
        } while (map[y][x] !== 0 || ghosts.some(g => g.x === x && g.y === y));
        
        ghosts.push({
          x: x,
          y: y,
          color: ghostColors[i],
          name: ghostNames[i]
        });
      }
      
      if (ghostMoveInterval) clearInterval(ghostMoveInterval);
      ghostMoveInterval = setInterval(moveGhosts, 350);
      
      // Update display elements
      document.getElementById('levelDisplay').innerText = `Level ${currentLevel}`;
      document.getElementById('livesDisplay').innerText = `Lives: ${playerLives}`;
      message.innerText = '';
      draw();
    }

    function draw() {
      const tileSize = window.tileSize || 20;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          if (map[y][x] === 1) {
            ctx.fillStyle = '#0033cc';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
          if (map[y][x] === 2) {
            // Draw door frame
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            
            // Draw door
            ctx.fillStyle = '#D2691E';
            ctx.fillRect(x * tileSize + 2, y * tileSize + 2, tileSize - 4, tileSize - 4);
            
            // Draw door panels
            ctx.fillStyle = '#CD853F';
            ctx.fillRect(x * tileSize + 4, y * tileSize + 4, (tileSize - 8) / 2, (tileSize - 8) / 2);
            ctx.fillRect(x * tileSize + 4 + (tileSize - 8) / 2, y * tileSize + 4, (tileSize - 8) / 2, (tileSize - 8) / 2);
            ctx.fillRect(x * tileSize + 4, y * tileSize + 4 + (tileSize - 8) / 2, (tileSize - 8) / 2, (tileSize - 8) / 2);
            ctx.fillRect(x * tileSize + 4 + (tileSize - 8) / 2, y * tileSize + 4 + (tileSize - 8) / 2, (tileSize - 8) / 2, (tileSize - 8) / 2);
            
            // Draw door handle
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x * tileSize + tileSize * 0.75, y * tileSize + tileSize * 0.5, 2, 0, 2 * Math.PI);
            ctx.fill();
          }
          

          if (pelletMap[y][x] === 1) {
            ctx.beginPath();
            ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 3, 0, 2 * Math.PI);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
          }
        }
      }
      
      // Draw ghosts
      for (const ghost of ghosts) {
        ctx.beginPath();
        ctx.arc(
          ghost.x * tileSize + tileSize / 2,
          ghost.y * tileSize + tileSize / 2,
          tileSize / 2 - 3,
          Math.PI, 0, false
        );
        ctx.lineTo(ghost.x * tileSize + tileSize - 3, ghost.y * tileSize + tileSize - 3);
        ctx.lineTo(ghost.x * tileSize + 3, ghost.y * tileSize + tileSize - 3);
        ctx.closePath();
        ctx.fillStyle = ghost.color;
        ctx.fill();
        
        // Eyes
        ctx.beginPath();
        ctx.arc(ghost.x * tileSize + tileSize/2 - 4, ghost.y * tileSize + tileSize/2 - 1, 2, 0, 2 * Math.PI);
        ctx.arc(ghost.x * tileSize + tileSize/2 + 4, ghost.y * tileSize + tileSize/2 - 1, 2, 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(ghost.x * tileSize + tileSize/2 - 4, ghost.y * tileSize + tileSize/2 - 1, 0.8, 0, 2 * Math.PI);
        ctx.arc(ghost.x * tileSize + tileSize/2 + 4, ghost.y * tileSize + tileSize/2 - 1, 0.8, 0, 2 * Math.PI);
        ctx.fillStyle = '#222';
        ctx.fill();
        
        // Draw ghost name above (smaller for portrait mode)
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.fillStyle = ghost.color;
        ctx.fillText(ghost.name, ghost.x * tileSize + tileSize / 2, ghost.y * tileSize - 2);
      }
      
      // Draw Pacman
      ctx.beginPath();
      ctx.arc(
        pacman.x * tileSize + tileSize / 2,
        pacman.y * tileSize + tileSize / 2,
        tileSize / 2 - 1,
        0.25 * Math.PI, 1.75 * Math.PI, false
      );
      ctx.lineTo(
        pacman.x * tileSize + tileSize / 2,
        pacman.y * tileSize + tileSize / 2
      );
      ctx.closePath();
      ctx.fillStyle = 'yellow';
      ctx.fill();
    }

    function moveGhosts() {
      for (const ghost of ghosts) {
        // Try random directions until a valid move is found
        const dirs = [ [0, -1], [0, 1], [-1, 0], [1, 0] ];
        for (let i = dirs.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
        }
        for (const [dx, dy] of dirs) {
          const nx = ghost.x + dx;
          const ny = ghost.y + dy;
          if (map[ny] && map[ny][nx] === 0 && !ghosts.some(g => g !== ghost && g.x === nx && g.y === ny)) {
            ghost.x = nx;
            ghost.y = ny;
            break;
          }
        }
      }
      // Check collision with Pac-Man
      for (const ghost of ghosts) {
        if (ghost.x === pacman.x && ghost.y === pacman.y) {
          playerLives--;
          if (playerLives <= 0) {
            message.innerText = 'Game Over!';
            clearInterval(ghostMoveInterval);
            setTimeout(() => {
              currentLevel = 1;
              resetGame();
            }, 1500);
            return;
                      } else {
              document.getElementById('livesDisplay').innerText = `Lives: ${playerLives}`;
              message.innerText = `Lost a life! Lives remaining: ${playerLives}`;
              // Reset Pacman position
              pacman.x = 1;
              pacman.y = 1;
              draw();
              return;
            }
        }
      }
      draw();
    }

    function tryMove(dx, dy) {
      const nx = pacman.x + dx;
      const ny = pacman.y + dy;
      if (map[ny] && (map[ny][nx] === 0 || map[ny][nx] === 2)) {
        pacman.x = nx;
        pacman.y = ny;
        
        // Check if Pacman reached the door (win condition)
        if (map[ny][nx] === 2) {
          if (currentLevel >= 100) {
            message.innerText = '🎉 Congratulations! You completed all 100 levels! 🎉';
            clearInterval(ghostMoveInterval);
            setTimeout(() => {
              currentLevel = 1;
              resetGame();
            }, 3000);
            return;
          } else {
            currentLevel++;
            message.innerText = `🎉 Level ${currentLevel - 1} Complete! 🎉`;
            clearInterval(ghostMoveInterval);
            setTimeout(resetGame, 1200);
            return;
          }
        }
        
        if (pelletMap[ny][nx] === 1) {
          pelletMap[ny][nx] = 0;
          pelletsLeft--;
          // Play waka-waka sound when eating a pellet
          try {
            wakaSound.currentTime = 0;
            wakaSound.play();
          } catch (e) {}
        }
        // Check collision with ghosts after Pac-Man moves
        for (const ghost of ghosts) {
          if (ghost.x === pacman.x && ghost.y === pacman.y) {
            playerLives--;
            if (playerLives <= 0) {
              message.innerText = 'Game Over!';
              clearInterval(ghostMoveInterval);
              setTimeout(() => {
                currentLevel = 1;
                resetGame();
              }, 1500);
              return;
            } else {
              document.getElementById('livesDisplay').innerText = `Lives: ${playerLives}`;
              message.innerText = `Lost a life! Lives remaining: ${playerLives}`;
              // Reset Pacman position
              pacman.x = 1;
              pacman.y = 1;
              draw();
              return;
            }
          }
        }
      }
      draw();
    }

    // Keyboard controls
    document.addEventListener('keydown', e => {
      switch (e.key) {
        case 'ArrowUp': tryMove(0, -1); break;
        case 'ArrowDown': tryMove(0, 1); break;
        case 'ArrowLeft': tryMove(-1, 0); break;
        case 'ArrowRight': tryMove(1, 0); break;
      }
    });

    // Mobile touch controls with iOS support
    document.querySelectorAll('.control-btn').forEach(btn => {
      let touchStartTime = 0;
      let touchEndTime = 0;
      
      // Handle touch events for iOS
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchStartTime = Date.now();
        btn.style.transform = 'scale(0.95)';
        btn.style.background = 'rgba(255, 215, 0, 0.5)';
      });
      
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchEndTime = Date.now();
        
        // Only trigger if it's a quick tap (not a long press)
        if (touchEndTime - touchStartTime < 300) {
          const direction = btn.dataset.direction;
          switch (direction) {
            case 'up': tryMove(0, -1); break;
            case 'down': tryMove(0, 1); break;
            case 'left': tryMove(-1, 0); break;
            case 'right': tryMove(1, 0); break;
          }
        }
        
        // Reset button appearance
        btn.style.transform = 'scale(1)';
        btn.style.background = 'rgba(255, 215, 0, 0.2)';
      });
      
      // Handle mouse clicks for desktop
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        
        const direction = btn.dataset.direction;
        switch (direction) {
          case 'up': tryMove(0, -1); break;
          case 'down': tryMove(0, 1); break;
          case 'left': tryMove(-1, 0); break;
          case 'right': tryMove(1, 0); break;
        }
      });
      
      // Prevent context menu on long press
      btn.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
    });

    newGameBtn.addEventListener('click', resetGame);

    // Initialize game
    resetGame();
  </script>
</body>
</html> 