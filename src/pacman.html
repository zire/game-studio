<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Brandon's Pacman">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#FFD700">
  <meta name="description" content="Brandon's Pacman Game Studio - Fun maze adventure game with weapons and ghosts">
  <meta name="keywords" content="pacman, game, maze, arcade, mobile, pwa">
  <meta name="author" content="Brandon Yang">
  <meta name="robots" content="noindex, nofollow">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
  <title>Brandon's Pacman Game Studio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --sat: env(safe-area-inset-top);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);
      --sar: env(safe-area-inset-right);
    }
    
    body { 
      background: #000; 
      margin: 0; 
      padding: 0;
      padding-top: var(--sat);
      padding-bottom: var(--sab);
      padding-left: var(--sal);
      padding-right: var(--sar);
      display: flex; 
      align-items: center; 
      justify-content: center; 
      min-height: 100vh;
      height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    
    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 10px;
      padding: 10px;
      padding-top: max(10px, env(safe-area-inset-top) + 10px);
      width: 100%;
      max-width: 400px;
      min-height: 100vh;
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    /* Hamburger Menu */
    .hamburger-menu {
      position: fixed;
      top: max(10px, env(safe-area-inset-top) + 10px);
      left: max(10px, env(safe-area-inset-left) + 10px);
      z-index: 1000;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #FFD700;
      border-radius: 8px;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      touch-action: manipulation;
    }
    
    .hamburger-menu:hover {
      background: rgba(255, 215, 0, 0.2);
    }
    
    .hamburger-menu:active {
      transform: scale(0.95);
    }
    
    .hamburger-icon {
      width: 20px;
      height: 16px;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    
    .hamburger-icon span {
      display: block;
      height: 2px;
      width: 100%;
      background: #FFD700;
      border-radius: 1px;
      transition: all 0.3s ease;
    }
    
    .hamburger-menu.active .hamburger-icon span:nth-child(1) {
      transform: rotate(45deg) translate(5px, 5px);
    }
    
    .hamburger-menu.active .hamburger-icon span:nth-child(2) {
      opacity: 0;
    }
    
    .hamburger-menu.active .hamburger-icon span:nth-child(3) {
      transform: rotate(-45deg) translate(7px, -6px);
    }
    
    /* Menu Overlay */
    .menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .menu-overlay.active {
      display: flex;
    }
    
    .menu-content {
      background: #111;
      border: 2px solid #FFD700;
      border-radius: 12px;
      padding: 20px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
      color: #FFD700;
      font-family: Arial, sans-serif;
    }
    
    .menu-content h2 {
      margin: 0 0 15px 0;
      text-align: center;
      font-size: 1.5em;
    }
    
    .menu-content h3 {
      margin: 15px 0 8px 0;
      color: #FFD700;
      font-size: 1.2em;
    }
    
    .menu-content p {
      margin: 8px 0;
      line-height: 1.4;
    }
    
    .menu-content ul {
      margin: 8px 0;
      padding-left: 20px;
    }
    
    .menu-content li {
      margin: 4px 0;
      line-height: 1.3;
    }
    
    .close-menu {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #FFD700;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
      transition: background 0.3s ease;
    }
    
    .close-menu:hover {
      background: rgba(255, 215, 0, 0.2);
    }
    
    canvas { 
      border: 2px solid #fff; 
      background: #111; 
      display: block; 
      margin: 0 auto;
      max-width: 100%;
      max-height: 60vh;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }
    

    
    .level-info {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 400px;
      margin-bottom: 8px;
      font-family: monospace;
      font-size: 0.85em;
      color: #FFD700;
      gap: 15px;
      flex-wrap: nowrap;
    }
    
    #levelDisplay, #livesDisplay, #scoreDisplay {
      background: none;
      padding: 0;
      border: none;
      font-size: inherit;
      white-space: nowrap;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }
    
    #message {
      color: yellow;
      font-family: monospace;
      font-size: 1.5em;
      text-shadow: 2px 2px 8px #000;
      text-align: center;
      min-height: 40px;
    }
    
    /* Mobile Controls */
    .mobile-controls {
      display: none;
      flex-direction: row;
      justify-content: center;
      gap: 15px;
      margin-top: 15px;
      padding: 0 10px;
    }
    
    .control-row {
      display: none;
    }
    
    .control-btn {
      width: 55px;
      height: 55px;
      background: rgba(255, 215, 0, 0.2);
      border: 2px solid #FFD700;
      border-radius: 50%;
      color: #FFD700;
      font-size: 22px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      margin: 0;
    }
    
    .control-btn:active {
      background: rgba(255, 215, 0, 0.5);
      transform: scale(0.95);
    }
    
    .control-btn.up { font-size: 20px; }
    .control-btn.down { font-size: 20px; }
    .control-btn.left { font-size: 20px; }
    .control-btn.right { font-size: 20px; }
    
    /* Weapon Controls */
    .weapon-controls {
      display: none;
      flex-direction: row;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
      padding: 0 10px;
    }
    
    .weapon-btn {
      width: 70px;
      height: 70px;
      background: rgba(255, 69, 0, 0.2);
      border: 2px solid #FF4500;
      border-radius: 50%;
      color: #FF4500;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      margin: 0;
      position: relative;
      overflow: hidden;
    }
    
    .weapon-btn.freeze-wind {
      background: rgba(0, 191, 255, 0.2);
      border-color: #00BFFF;
      color: #00BFFF;
    }
    
    .weapon-btn:disabled {
      opacity: 0.3;
      background: rgba(100, 100, 100, 0.3);
      border-color: #666;
      color: #666;
      cursor: not-allowed;
    }
    
    .weapon-btn.freeze-wind:disabled {
      background: rgba(100, 100, 100, 0.3);
      border-color: #666;
      color: #666;
    }
    
    .weapon-btn:active:not(:disabled) {
      transform: scale(0.95);
    }
    
    .weapon-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .weapon-icon {
      font-size: 20px;
      margin-bottom: 2px;
    }
    
    .cooldown-text {
      font-size: 8px;
      font-family: monospace;
      text-align: center;
      line-height: 1;
    }
    
    .cooldown-progress {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: conic-gradient(from 0deg, transparent 0deg, transparent 0deg);
      transition: background 0.05s linear;
      pointer-events: none;
      z-index: 1;
    }
    
    .weapon-btn .weapon-icon,
    .weapon-btn .cooldown-text {
      position: relative;
      z-index: 2;
    }
    
    /* Player Tips */
    .player-tips {
      background: rgba(255, 215, 0, 0.15);
      border: 2px solid #FFD700;
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      max-width: 400px;
      width: 100%;
      z-index: 10;
      display: block !important;
    }
    
    .tips-header {
      color: #FFD700;
      font-weight: bold;
      font-size: 16px;
      text-align: center;
      margin-bottom: 10px;
      font-family: monospace;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }
    
    .tips-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .tip-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: #ccc;
      line-height: 1.3;
    }
    
    .tip-icon {
      font-size: 14px;
      min-width: 20px;
      text-align: center;
    }
    
    .tip-text {
      flex: 1;
    }
    
    /* Instructions */
    .instructions {
      color: #ccc;
      text-align: center;
      font-size: 12px;
      margin-top: 8px;
      opacity: 0.8;
    }
    
    /* Studio Credit */
    .studio-credit {
      color: #FFD700;
      text-align: center;
      font-size: 11px;
      font-family: monospace;
      margin-top: 15px;
      margin-bottom: 10px;
      opacity: 0.9;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      letter-spacing: 0.5px;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
      
      .weapon-controls {
        display: flex;
      }
      
      .instructions {
        font-size: 11px;
      }
      
      .player-tips {
        padding: 10px;
        margin: 8px 0;
      }
      
      .tips-header {
        font-size: 13px;
      }
      
      .tip-item {
        font-size: 10px;
        gap: 6px;
      }
      
      .tip-icon {
        font-size: 12px;
        min-width: 18px;
      }
      
      #message {
        font-size: 1.3em;
        min-height: 35px;
      }
      
      #newGameBtn {
        font-size: 1em;
        padding: 8px 16px;
      }
      
      .level-info {
        font-size: 0.8em;
        gap: 12px;
        margin-bottom: 6px;
      }
      
      #levelDisplay, #livesDisplay, #scoreDisplay {
        font-size: inherit;
        padding: 0;
      }
    }
    
    @media (max-width: 480px) {
      .game-container {
        padding: 8px;
        gap: 12px;
        justify-content: flex-start;
        padding-top: max(8px, env(safe-area-inset-top) + 8px);
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      .weapon-btn {
        width: 60px;
        height: 60px;
        font-size: 20px;
      }
      
      .weapon-icon {
        font-size: 18px;
      }
      
      .cooldown-text {
        font-size: 7px;
      }
      
      .mobile-controls {
        gap: 10px;
        margin-top: 12px;
      }
      
      .level-info {
        font-size: 0.75em;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
      }
      
      #levelDisplay, #livesDisplay, #scoreDisplay {
        font-size: inherit;
        padding: 0;
      }
    }
    
    /* iPhone 16 Pro Max and similar large phones */
    @media (max-width: 430px) and (min-height: 800px) {
      .game-container {
        padding-top: max(15px, env(safe-area-inset-top) + 15px);
        gap: 8px;
      }
      
      .level-info {
        font-size: 0.8em;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        width: 100%;
        max-width: 350px;
        gap: 10px;
      }
      
      #levelDisplay, #livesDisplay, #scoreDisplay {
        font-size: inherit;
        padding: 0;
      }
      
      canvas {
        max-height: 60vh;
      }
      
      .mobile-controls {
        margin-top: 15px;
      }
    }
    
    /* Ultra-wide phones */
    @media (max-width: 360px) {
      .game-container {
        padding-top: max(6px, env(safe-area-inset-top) + 6px);
      }
      
      .level-info {
        font-size: 0.7em;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        gap: 6px;
      }
      
      #levelDisplay, #livesDisplay, #scoreDisplay {
        font-size: inherit;
        padding: 0;
      }
      
      .control-btn {
        width: 45px;
        height: 45px;
        font-size: 18px;
      }
      
      .weapon-btn {
        width: 55px;
        height: 55px;
        font-size: 18px;
      }
      
      .weapon-icon {
        font-size: 16px;
      }
      
      .cooldown-text {
        font-size: 6px;
      }
      
      .mobile-controls {
        gap: 8px;
        margin-top: 10px;
      }
      
      .studio-credit {
        font-size: 10px;
        margin-top: 12px;
        margin-bottom: 8px;
      }
      
      .player-tips {
        padding: 8px;
        margin: 6px 0;
      }
      
      .tips-header {
        font-size: 12px;
      }
      
      .tip-item {
        font-size: 9px;
        gap: 5px;
      }
      
      .tip-icon {
        font-size: 11px;
        min-width: 16px;
      }
    }
    
    /* Portrait mode optimizations */
    @media (orientation: portrait) {
      .game-container {
        max-width: 350px;
        height: 100vh;
      }
      
      canvas {
        max-height: 60vh;
      }
      
      #message {
        font-size: 1.1em;
      }
    }
    
    /* Portrait mode optimizations */
    @media (orientation: portrait) {
      .game-container {
        max-width: 350px;
        height: 100vh;
      }
      
      canvas {
        max-height: 60vh;
      }
    }
    
    /* Firefox mobile specific fixes */
    @-moz-document url-prefix() {
      body {
        height: 100vh;
        min-height: 100vh;
      }
      
      .game-container {
        height: 100vh;
        min-height: 100vh;
      }
    }
    
    /* Dynamic Island and notch devices */
    @supports (padding-top: env(safe-area-inset-top)) {
      .game-container {
        padding-top: max(10px, env(safe-area-inset-top) + 10px);
      }
      
      @media (max-width: 430px) and (min-height: 800px) {
        .game-container {
          padding-top: max(20px, env(safe-area-inset-top) + 20px);
        }
      }
    }
  </style>
</head>
  <body>
    <!-- Hamburger Menu Button -->
    <div class="hamburger-menu" id="hamburgerMenu">
      <div class="hamburger-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>
    
    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay">
      <div class="menu-content">
        <button class="close-menu" id="closeMenu">×</button>
        <h2>🎮 Pacman Game Guide</h2>
        
        <h3>🎯 How to Play</h3>
        <p>Navigate through the maze, collect all golden pellets, and reach the exit door while avoiding ghosts!</p>
        
        <h3>🎮 Controls</h3>
        <ul>
          <li><strong>Desktop:</strong> Arrow keys or WASD to move</li>
          <li><strong>Mobile:</strong> Use the touch controls below the game</li>
          <li><strong>Spacebar:</strong> Fire blast weapon 🔥</li>
          <li><strong>F key:</strong> Freeze wind weapon ❄️</li>
        </ul>
        
        <h3>⚔️ Weapons</h3>
        <ul>
          <li><strong>Fire Blast 🔥:</strong> Long-range, high damage, long cooldown</li>
          <li><strong>Freeze Wind ❄️:</strong> Short-range, crowd control, medium cooldown</li>
          <li>Weapons can defeat ghosts temporarily</li>
          <li>Watch the cooldown circles on weapon buttons</li>
        </ul>
        
        <h3>👻 Ghosts</h3>
        <ul>
          <li>Ghosts respawn after being defeated</li>
          <li>They spawn at safe distances from Pacman</li>
          <li>More ghosts appear in higher levels</li>
        </ul>
        
        <h3>📊 Scoring</h3>
        <ul>
          <li>Complete levels quickly for higher scores</li>
          <li>Survive with more lives for bonus points</li>
          <li>Track your progress across 100 levels!</li>
        </ul>
        
        <h3>💡 Tips</h3>
        <ul>
          <li>Plan your route before moving</li>
          <li>Use weapons strategically</li>
          <li>Don't get cornered by ghosts</li>
          <li>Practice makes perfect!</li>
        </ul>
        
        <h3>📱 PWA Features</h3>
        <p>This game works offline! Add it to your home screen for the best experience.</p>
      </div>
    </div>
    
    <div class="game-container">
      <div class="level-info">
        <span id="levelDisplay">Level 1</span>
        <span id="livesDisplay">Lives: 5</span>
        <span id="scoreDisplay">Total: 0 | Avg: 0</span>
      </div>
  
      <canvas id="game" width="300" height="480"></canvas>
      <div id="message"></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
      <button class="control-btn left" data-direction="left">←</button>
      <button class="control-btn up" data-direction="up">↑</button>
      <button class="control-btn down" data-direction="down">↓</button>
      <button class="control-btn right" data-direction="right">→</button>
    </div>
    
    <!-- Weapon Controls -->
    <div class="weapon-controls">
      <button class="weapon-btn fire-blast" data-weapon="fire" disabled>
        <div class="cooldown-progress"></div>
        <span class="weapon-icon">🔥</span>
        <span class="cooldown-text">Ready</span>
      </button>
      <button class="weapon-btn freeze-wind" data-weapon="freeze" disabled>
        <div class="cooldown-progress"></div>
        <span class="weapon-icon">❄️</span>
        <span class="cooldown-text">Ready</span>
      </button>
    </div>
    
    <div class="instructions">
      <div id="desktop-instructions">Use arrow keys to move <svg width="16" height="16" viewBox="0 0 16 16" style="display: inline-block; vertical-align: middle;">
        <g transform="rotate(45 8 8)">
          <path d="M8 1 A7 7 0 1 1 8 15 A7 7 0 0 1 8 1 M8 1 L8 8 L15 8 A7 7 0 0 0 8 1 Z" fill="#FFD700" stroke="#000" stroke-width="0.5"/>
        </g>
      </svg> to 🍎 | Spacebar: 🔥 Fire Blast | F: ❄️ Freeze Wind</div>
      <div id="mobile-instructions" style="display: none;">Tap the arrow buttons to move <svg width="16" height="16" viewBox="0 0 16 16" style="display: inline-block; vertical-align: middle;">
        <g transform="rotate(45 8 8)">
          <path d="M8 1 A7 7 0 1 1 8 15 A7 7 0 0 1 8 1 M8 1 L8 8 L15 8 A7 7 0 0 0 8 1 Z" fill="#FFD700" stroke="#000" stroke-width="0.5"/>
        </g>
      </svg> to 🍎 | Use weapon buttons below</div>
    </div>
    
    <!-- Player Tips -->
    <div class="player-tips">
      <div class="tips-header">💡 Player Tips</div>
      <div class="tips-content">
        <div class="tip-item">
          <span class="tip-icon">🔥</span>
          <span class="tip-text">Fire Blast: Long range, high damage, 5s cooldown</span>
        </div>
        <div class="tip-item">
          <span class="tip-icon">❄️</span>
          <span class="tip-text">Freeze Wind: Short range, crowd control, 3s cooldown</span>
        </div>
        <div class="tip-item">
          <span class="tip-icon">🎯</span>
          <span class="tip-text">Weapons only hit ghosts in the direction you're facing</span>
        </div>
        <div class="tip-item">
          <span class="tip-icon">⚡</span>
          <span class="tip-text">Frozen ghosts can't move, burning ghosts get eliminated</span>
        </div>
      </div>
    </div>
    
    <div class="studio-credit">
      Produced by Brandonator Awesome Game Studio<br>
      B·A·G·S
    </div>
  </div>

  <script>
    // Portrait-optimized maze dimensions
    const mapWidth = 10;  // Back to original size
    const mapHeight = 16; // Taller for portrait
    
    // Responsive canvas sizing for portrait mode
    function resizeCanvas() {
      const canvas = document.getElementById('game');
      
      // Account for safe areas on mobile devices
      const safeAreaTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sat') || '0');
      const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sab') || '0');
      
      const availableWidth = window.innerWidth - 20;
      const availableHeight = window.innerHeight - safeAreaTop - safeAreaBottom - 200; // Account for UI elements
      
      const maxWidth = Math.min(availableWidth, 350);
      const maxHeight = Math.min(availableHeight, 480);
      
      // For portrait mode, prioritize height
      let size;
      if (window.innerHeight > window.innerWidth) {
        // Portrait mode - use height as primary constraint
        size = Math.min(maxHeight / mapHeight, maxWidth / mapWidth);
      } else {
        // Landscape mode - use width as primary constraint
        size = Math.min(maxWidth / mapWidth, maxHeight / mapHeight);
      }
      
      // Ensure minimum size for playability
      size = Math.max(size, 15);
      
      const canvasWidth = mapWidth * size;
      const canvasHeight = mapHeight * size;
      
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // Update tile size based on canvas size
      window.tileSize = size;
    }
    
    // Initialize responsive design
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Show/hide instructions based on device
    function updateInstructions() {
      const isMobile = window.innerWidth <= 768;
      document.getElementById('desktop-instructions').style.display = isMobile ? 'none' : 'block';
      document.getElementById('mobile-instructions').style.display = isMobile ? 'block' : 'none';
    }
    updateInstructions();
    window.addEventListener('resize', updateInstructions);
    
    // Ensure player tips are visible
    function ensureTipsVisible() {
      const tipsElement = document.querySelector('.player-tips');
      if (tipsElement) {
        tipsElement.style.display = 'block';
        tipsElement.style.visibility = 'visible';
        tipsElement.style.opacity = '1';
        console.log('Player tips element found and made visible');
      } else {
        console.log('Player tips element not found');
      }
    }
    
    // Run after DOM is loaded
    document.addEventListener('DOMContentLoaded', ensureTipsVisible);
    // Also run immediately in case DOM is already loaded
    ensureTipsVisible();

    // Load waka-waka sound effect
    const wakaSound = new Audio('waka.wav');
    wakaSound.volume = 0.5;

    function generateRandomMap(level = 1) {
      // Maze generation using randomized DFS with level-based complexity
      const newMap = [];
      for (let y = 0; y < mapHeight; y++) {
        const row = [];
        for (let x = 0; x < mapWidth; x++) {
          row.push(1); // Start with all walls
        }
        newMap.push(row);
      }
      
      // Calculate complexity based on level
      const complexity = Math.min(1.0, level / 50); // 0.0 to 1.0 based on level
      const extraOpenRate = 0.05 + (complexity * 0.15); // 5% to 20% extra openings
      const deadEndDensity = complexity * 0.3; // 0% to 30% chance of creating dead ends

      // Helper to shuffle directions
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      // DFS maze generation (full maze including exit door position)
      function carve(x, y) {
        newMap[y][x] = 0;
        const dirs = [ [0, -2], [0, 2], [-2, 0], [2, 0] ];
        shuffle(dirs);
        for (const [dx, dy] of dirs) {
          const nx = x + dx, ny = y + dy;
          if (ny > 0 && ny < mapHeight-1 && nx > 0 && nx < mapWidth-1 && newMap[ny][nx] === 1) {
            newMap[y + dy/2][x + dx/2] = 0; // Remove wall between
            carve(nx, ny);
          }
        }
      }

      carve(1, 1); // Start maze at (1,1)

      // Ensure (1,1) is open
      newMap[1][1] = 0;
      
      // Place exit door at bottom-right corner
      newMap[mapHeight - 2][mapWidth - 2] = 2; // Door
      
      // Ensure the door is connected to the maze
      // Create a guaranteed path from the maze to the door
      let doorConnected = false;
      
      // Try to connect from the left of the door
      if (newMap[mapHeight - 2][mapWidth - 3] === 0) {
        doorConnected = true;
      }
      // Try to connect from above the door
      else if (newMap[mapHeight - 3][mapWidth - 2] === 0) {
        doorConnected = true;
      }
      // If not connected, force a connection from the left
      if (!doorConnected) {
        newMap[mapHeight - 2][mapWidth - 3] = 0; // Open the cell to the left of the door
      }

      // Now add extra openings while maintaining connectivity
      let extraOpens = Math.floor((mapWidth * mapHeight) * extraOpenRate);
      let attempts = 0;
      const maxAttempts = extraOpens * 10; // Limit attempts to prevent infinite loop
      
      while (extraOpens > 0 && attempts < maxAttempts) {
        const rx = 1 + Math.floor(Math.random() * (mapWidth - 2));
        const ry = 1 + Math.floor(Math.random() * (mapHeight - 2));
        
        // Only open walls that are adjacent to existing paths
        if (newMap[ry][rx] === 1 && isAdjacentToPath(newMap, rx, ry, deadEndDensity)) {
          // Temporarily open the wall
          newMap[ry][rx] = 0;
          
          // Check if this creates any isolated areas
          if (!createsIsolatedAreas(newMap, rx, ry)) {
            extraOpens--;
          } else {
            // Revert if it creates isolated areas
            newMap[ry][rx] = 1;
          }
        }
        attempts++;
      }
      
      return newMap;
    }

    // Check if a wall is adjacent to an existing path
    function isAdjacentToPath(map, x, y, deadEndDensity = 0) {
      const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
      let pathCount = 0;
      
      for (const [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        
        if (ny >= 0 && ny < mapHeight && nx >= 0 && nx < mapWidth && 
            (map[ny][nx] === 0 || map[ny][nx] === 2)) {
          pathCount++;
        }
      }
      
      // For higher levels, allow more dead ends and complex paths
      if (deadEndDensity > 0 && Math.random() < deadEndDensity) {
        // Allow dead ends (adjacent to only 1 path) more frequently
        return pathCount >= 1 && pathCount <= 3;
      } else {
        // Standard logic: avoid dead ends and isolated areas
        return pathCount >= 1 && pathCount <= 2;
      }
    }

    // Check if opening a wall creates isolated areas
    function createsIsolatedAreas(map, x, y) {
      // Temporarily open the wall
      const originalValue = map[y][x];
      map[y][x] = 0;
      
      // Count connected accessible areas
      const visited = new Set();
      const accessibleAreas = [];
      
      // Find all accessible areas
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          if ((map[y][x] === 0 || map[y][x] === 2) && !visited.has(`${x},${y}`)) {
            const areaSize = floodFill(map, x, y, visited);
            if (areaSize > 0) {
              accessibleAreas.push(areaSize);
            }
          }
        }
      }
      
      // Restore the wall
      map[y][x] = originalValue;
      
      // If there's more than one accessible area, we've created isolation
      return accessibleAreas.length > 1;
    }

    // Flood fill to count connected accessible cells
    function floodFill(map, startX, startY, visited) {
      const queue = [{x: startX, y: startY}];
      let count = 0;
      
      while (queue.length > 0) {
        const {x, y} = queue.shift();
        const key = `${x},${y}`;
        
        if (visited.has(key)) continue;
        visited.add(key);
        
        if (map[y][x] === 0 || map[y][x] === 2) {
          count++;
          
          // Check all 4 directions
          const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
          for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            
            if (ny >= 0 && ny < mapHeight && nx >= 0 && nx < mapWidth && 
                (map[ny][nx] === 0 || map[ny][nx] === 2) && !visited.has(`${nx},${ny}`)) {
              queue.push({x: nx, y: ny});
            }
          }
        }
      }
      
      return count;
    }

    // Calculate shortest path length using BFS
    function calculateShortestPath(map) {
      const queue = [{x: 1, y: 1, distance: 0}];
      const visited = new Set();
      const targetX = mapWidth - 2;
      const targetY = mapHeight - 2;
      
      while (queue.length > 0) {
        const {x, y, distance} = queue.shift();
        const key = `${x},${y}`;
        
        if (visited.has(key)) continue;
        visited.add(key);
        
        if (x === targetX && y === targetY) {
          return distance;
        }
        
        // Check all 4 directions
        const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
        for (const [dx, dy] of directions) {
          const nx = x + dx;
          const ny = y + dy;
          
          if (ny >= 0 && ny < mapHeight && nx >= 0 && nx < mapWidth && 
              (map[ny][nx] === 0 || map[ny][nx] === 2) && !visited.has(`${nx},${ny}`)) {
            queue.push({x: nx, y: ny, distance: distance + 1});
          }
        }
      }
      
      return Infinity; // No path found
    }

    // Get level parameters based on current level
    function getLevelParameters(level) {
      // Lives: 1 at level 1, 5 at level 100 (more lives to battle more ghosts)
      const lives = Math.min(5, 1 + Math.floor((level - 1) / 25));
      
      // Ghost count: Progressive difficulty
      let ghostCount;
      if (level <= 10) ghostCount = 1;      // Levels 1-10: 1 ghost
      else if (level <= 30) ghostCount = 2; // Levels 11-30: 2 ghosts
      else if (level <= 50) ghostCount = 3; // Levels 31-50: 3 ghosts
      else if (level <= 75) ghostCount = 4; // Levels 51-75: 4 ghosts
      else ghostCount = 5;                  // Levels 76-100: 5 ghosts
      
      // Target path length: shorter paths for higher levels (more difficult)
      const targetPathLength = Math.max(15, 50 - Math.floor((level - 1) / 2));
      
      return { lives, ghostCount, targetPathLength };
    }

    // Calculate score based on time, pellets collected, and lives remaining
    function calculateScore(timeElapsed, pelletsCollected, totalPellets, livesRemaining, maxLives) {
      // Time score: 0-40 points (faster = higher score)
      const maxTime = 300; // 5 minutes max
      const timeScore = Math.max(0, 40 - Math.floor((timeElapsed / 1000) * 40 / maxTime));
      
      // Pellet score: 0-40 points (more pellets = higher score)
      const pelletScore = Math.floor((pelletsCollected / totalPellets) * 40);
      
      // Life score: 0-20 points (more lives = higher score)
      const lifeScore = Math.floor((livesRemaining / maxLives) * 20);
      
      const totalScore = timeScore + pelletScore + lifeScore;
      return Math.min(100, totalScore); // Cap at 100
    }

    let map, pelletMap, pelletsLeft, pacman;
    let ghosts = [];
    let ghostMoveInterval = null;
    let currentLevel = 1;
    let playerLives = 5;
    let shortestPathLength = 0;
    let levelStartTime = 0;
    let currentScore = 0;
    let totalScore = 0;
    let completedLevels = 0;
    let averageScore = 0;
    let pelletsCollected = 0;
    let totalPelletsInLevel = 0;
    let celebrationParticles = [];
    let isCelebrating = false;
    let gameOverParticles = [];
    let isGameOverAnimating = false;
    
    // Weapon system variables
    let weaponParticles = [];
    let fireBlastCooldown = 0;
    let freezeWindCooldown = 0;
    let frozenGhosts = [];
    let burningGhosts = [];
    let weaponEffects = [];
    let weaponUpdateInterval = null;
    let lastWeaponUpdateTime = Date.now();
    let respawnQueue = [];
    
    // Sound effects
    let fireSound = null;
    let fireHitSound = null;
    let freezeSound = null;
    let gameOverSound = null;
    
    // Weapon cooldown times (in milliseconds)
    const FIRE_BLAST_COOLDOWN = 5000; // 5 seconds
    const FREEZE_WIND_COOLDOWN = 3000; // 3 seconds
    
    // Weapon damage and effects
    const FIRE_BLAST_DAMAGE = 50; // High DPS
    const FREEZE_WIND_DURATION = 2000; // 2 seconds freeze
    const FIRE_BLAST_RANGE = 5; // Long range
    const FREEZE_WIND_RANGE = 3; // Medium range (increased from 2)
    
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const message = document.getElementById('message');


    function resetGame() {
      // Reset celebration state
      isCelebrating = false;
      celebrationParticles = [];
      
      // Reset game over animation state
      isGameOverAnimating = false;
      gameOverParticles = [];
      
      // Reset weapon system
      weaponParticles = [];
      fireBlastCooldown = 0;
      freezeWindCooldown = 0;
      frozenGhosts = [];
      burningGhosts = [];
      weaponEffects = [];
      
      // Get level parameters
      const { lives, ghostCount, targetPathLength } = getLevelParameters(currentLevel);
      playerLives = lives;
      
      // Start timing for this level
      levelStartTime = Date.now();
      
      // Generate maze with appropriate difficulty
      let attempts = 0;
      let generatedMap;
      let pathLength;
      
      do {
        generatedMap = generateRandomMap(currentLevel);
        pathLength = calculateShortestPath(generatedMap);
        attempts++;
      } while (pathLength > targetPathLength + 10 && attempts < 20); // Try to get close to target path length
      
      map = generatedMap;
      shortestPathLength = pathLength;
      
      pelletMap = map.map((row, y) => row.map((cell, x) => {
        // Don't place pellets on the door
        if (cell === 2) return 0;
        return cell === 0 ? 1 : 0;
      }));
      pelletsLeft = pelletMap.flat().reduce((a, b) => a + b, 0);
      totalPelletsInLevel = pelletsLeft;
      pelletsCollected = 0;
      pacman = { x: 1, y: 1, direction: 'right' };
      
      // Generate ghosts based on level
      ghosts = [];
      const ghostNames = ['Clement', 'Chase', 'Ray', 'Jayden', 'Andrew'];
      const ghostColors = ['#147880', '#60EEE3', '#25BF94', '#E9E12E', '#FF6B41'];
      
      console.log(`Level ${currentLevel}: Spawning ${ghostCount} ghosts`);
      
      for (let i = 0; i < ghostCount; i++) {
        let x, y;
        do {
          x = 1 + Math.floor(Math.random() * (mapWidth - 3));
          y = 1 + Math.floor(Math.random() * (mapHeight - 3));
        } while (map[y][x] !== 0 || ghosts.some(g => g.x === x && g.y === y));
        
        ghosts.push({
          x: x,
          y: y,
          color: ghostColors[i],
          name: ghostNames[i]
        });
      }
      
      console.log(`Initial ghost count: ${ghosts.length}`);
      
      if (ghostMoveInterval) clearInterval(ghostMoveInterval);
      ghostMoveInterval = setInterval(moveGhosts, 350);
      
      // Start weapon particle update interval
      if (weaponUpdateInterval) clearInterval(weaponUpdateInterval);
      weaponUpdateInterval = setInterval(() => {
        updateWeaponParticles();
        updateWeaponCooldowns(); // Update cooldowns more frequently
        draw(); // Redraw to show updated particles
      }, 16); // Update every 16ms (60fps) for smooth animation
      
      // Debug: Log ghost count every 5 seconds
      setInterval(() => {
        console.log(`Current ghost count: ${ghosts.length}`);
        ghosts.forEach((ghost, index) => {
          console.log(`  Ghost ${index}: ${ghost.name} at (${ghost.x}, ${ghost.y})`);
        });
      }, 5000);
      
      // Update display elements
      document.getElementById('levelDisplay').innerText = `Level ${currentLevel}`;
      document.getElementById('livesDisplay').innerText = `Lives: ${playerLives}`;
      document.getElementById('scoreDisplay').innerText = `Total: ${totalScore} | Avg: ${averageScore}`;
      message.innerText = '';
      draw();
    }

    function createCelebrationParticles(x, y) {
      const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#FF9F43', '#00D2D3', '#54A0FF', '#5F27CD'];
      const emojis = ['🎉', '⭐', '🎊', '🏆', '💎', '🌟', '✨', '🎯', '🎨', '🚀', '🌈', '🎪', '🎭', '🎪', '🎡', '🎢'];
      const particleTypes = ['emoji', 'circle', 'star', 'sparkle'];
      
      // Random number of particles (20-30)
      const particleCount = 20 + Math.floor(Math.random() * 11);
      
      for (let i = 0; i < particleCount; i++) {
        const particleType = particleTypes[Math.floor(Math.random() * particleTypes.length)];
        const isSpecial = Math.random() < 0.15; // 15% chance for special particles
        
        celebrationParticles.push({
          x: x + (window.tileSize || 20) / 2,
          y: y + (window.tileSize || 20) / 2,
          vx: (Math.random() - 0.5) * (8 + Math.random() * 6), // More varied velocity
          vy: (Math.random() - 0.5) * (8 + Math.random() * 6) - 3,
          life: 0.8 + Math.random() * 0.4, // Varied starting life
          decay: 0.01 + Math.random() * 0.025, // Varied decay rates
          color: colors[Math.floor(Math.random() * colors.length)],
          emoji: emojis[Math.floor(Math.random() * emojis.length)],
          size: 15 + Math.random() * 20, // More size variation
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * (0.2 + Math.random() * 0.4), // Varied rotation
          bounce: 0.6 + Math.random() * 0.4, // Varied bounce
          gravity: 0.3 + Math.random() * 0.3, // Varied gravity
          type: particleType,
          isSpecial: isSpecial,
          pulse: Math.random() < 0.3, // 30% chance to pulse
          pulseSpeed: 0.05 + Math.random() * 0.1,
          pulsePhase: Math.random() * Math.PI * 2,
          trail: Math.random() < 0.2, // 20% chance for trail effect
          trailLength: 3 + Math.floor(Math.random() * 5),
          trailPositions: []
        });
      }
    }

    function updateCelebrationParticles() {
      for (let i = celebrationParticles.length - 1; i >= 0; i--) {
        const particle = celebrationParticles[i];
        
        // Update trail positions
        if (particle.trail) {
          particle.trailPositions.unshift({x: particle.x, y: particle.y, life: particle.life});
          if (particle.trailPositions.length > particle.trailLength) {
            particle.trailPositions.pop();
          }
        }
        
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += particle.gravity;
        particle.life -= particle.decay;
        particle.rotation += particle.rotationSpeed;
        
        // Update pulse phase
        if (particle.pulse) {
          particle.pulsePhase += particle.pulseSpeed;
        }
        
        // Special particles have different behaviors
        if (particle.isSpecial) {
          // Special particles might change direction randomly
          if (Math.random() < 0.02) {
            particle.vx += (Math.random() - 0.5) * 2;
            particle.vy += (Math.random() - 0.5) * 2;
          }
        }
        
        // Bounce off canvas edges
        const tileSize = window.tileSize || 20;
        const canvasWidth = mapWidth * tileSize;
        const canvasHeight = mapHeight * tileSize;
        
        if (particle.x <= 0 || particle.x >= canvasWidth) {
          particle.vx *= -particle.bounce;
          particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
        }
        if (particle.y >= canvasHeight) {
          particle.vy *= -particle.bounce;
          particle.y = canvasHeight;
        }
        
        if (particle.life <= 0) {
          celebrationParticles.splice(i, 1);
        }
      }
    }

    function drawCelebrationParticles() {
      celebrationParticles.forEach(particle => {
        ctx.save();
        
        // Calculate size with pulse effect
        let currentSize = particle.size;
        if (particle.pulse) {
          currentSize *= 0.8 + 0.4 * Math.sin(particle.pulsePhase);
        }
        
        // Draw trail if enabled
        if (particle.trail && particle.trailPositions.length > 0) {
          particle.trailPositions.forEach((pos, index) => {
            const trailAlpha = (particle.trailPositions.length - index) / particle.trailPositions.length * particle.life * 0.3;
            ctx.globalAlpha = trailAlpha;
            ctx.translate(pos.x, pos.y);
            ctx.rotate(particle.rotation);
            
            if (particle.type === 'emoji') {
              ctx.font = `${currentSize * 0.6}px Arial`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(particle.emoji, 0, 0);
            } else if (particle.type === 'circle') {
              ctx.beginPath();
              ctx.arc(0, 0, currentSize * 0.3, 0, 2 * Math.PI);
              ctx.fillStyle = particle.color;
              ctx.fill();
            } else if (particle.type === 'star') {
              drawStar(ctx, 0, 0, currentSize * 0.3, currentSize * 0.15, 5);
              ctx.fillStyle = particle.color;
              ctx.fill();
            } else if (particle.type === 'sparkle') {
              drawSparkle(ctx, 0, 0, currentSize * 0.4);
            }
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
          });
        }
        
        // Draw main particle
        ctx.globalAlpha = particle.life;
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation);
        
        if (particle.type === 'emoji') {
          ctx.font = `${currentSize}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, 0, 0);
        } else if (particle.type === 'circle') {
          ctx.beginPath();
          ctx.arc(0, 0, currentSize * 0.5, 0, 2 * Math.PI);
          ctx.fillStyle = particle.color;
          ctx.fill();
        } else if (particle.type === 'star') {
          drawStar(ctx, 0, 0, currentSize * 0.5, currentSize * 0.25, 5);
          ctx.fillStyle = particle.color;
          ctx.fill();
        } else if (particle.type === 'sparkle') {
          drawSparkle(ctx, 0, 0, currentSize * 0.6);
        }
        
        ctx.restore();
      });
    }

    function drawStar(ctx, cx, cy, outerRadius, innerRadius, points) {
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const angle = (i * Math.PI) / points;
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const x = cx + Math.cos(angle) * radius;
        const y = cy + Math.sin(angle) * radius;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
    }

    function drawSparkle(ctx, x, y, size) {
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      
      // Draw cross pattern
      ctx.beginPath();
      ctx.moveTo(x - size, y);
      ctx.lineTo(x + size, y);
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
      ctx.stroke();
      
      // Draw diagonal lines
      ctx.beginPath();
      ctx.moveTo(x - size * 0.7, y - size * 0.7);
      ctx.lineTo(x + size * 0.7, y + size * 0.7);
      ctx.moveTo(x - size * 0.7, y + size * 0.7);
      ctx.lineTo(x + size * 0.7, y - size * 0.7);
      ctx.stroke();
    }

    function createGameOverParticles(x, y) {
      const colors = ['#FF0000', '#8B0000', '#DC143C', '#B22222', '#CD5C5C', '#F08080'];
      const emojis = ['💀', '👻', '💥', '💢', '😵', '💀', '⚰️', '🪦'];
      const particleTypes = ['emoji', 'skull', 'explosion', 'smoke'];
      
      // Create more dramatic effect for game over
      const particleCount = 30 + Math.floor(Math.random() * 15);
      
      for (let i = 0; i < particleCount; i++) {
        const particleType = particleTypes[Math.floor(Math.random() * particleTypes.length)];
        const isDramatic = Math.random() < 0.25; // 25% chance for dramatic particles
        
        gameOverParticles.push({
          x: x + (window.tileSize || 20) / 2,
          y: y + (window.tileSize || 20) / 2,
          vx: (Math.random() - 0.5) * (12 + Math.random() * 8), // Faster, more explosive
          vy: (Math.random() - 0.5) * (12 + Math.random() * 8) - 5, // More upward movement
          life: 1.0 + Math.random() * 0.5, // Longer life for dramatic effect
          decay: 0.008 + Math.random() * 0.015, // Slower decay
          color: colors[Math.floor(Math.random() * colors.length)],
          emoji: emojis[Math.floor(Math.random() * emojis.length)],
          size: 20 + Math.random() * 25, // Larger particles
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * (0.3 + Math.random() * 0.5), // Faster rotation
          bounce: 0.4 + Math.random() * 0.3, // Less bounce for dramatic effect
          gravity: 0.2 + Math.random() * 0.4, // Varied gravity
          type: particleType,
          isDramatic: isDramatic,
          shake: Math.random() < 0.4, // 40% chance to shake
          shakeIntensity: 0.5 + Math.random() * 1.5,
          shakeSpeed: 0.1 + Math.random() * 0.2,
          shakePhase: Math.random() * Math.PI * 2,
          smoke: Math.random() < 0.3, // 30% chance for smoke effect
          smokeOpacity: 0.3 + Math.random() * 0.4,
          originalX: x + (window.tileSize || 20) / 2,
          originalY: y + (window.tileSize || 20) / 2
        });
      }
    }

    function updateGameOverParticles() {
      for (let i = gameOverParticles.length - 1; i >= 0; i--) {
        const particle = gameOverParticles[i];
        
        // Update shake effect
        if (particle.shake) {
          particle.shakePhase += particle.shakeSpeed;
          particle.x = particle.originalX + Math.sin(particle.shakePhase) * particle.shakeIntensity;
          particle.y = particle.originalY + Math.cos(particle.shakePhase) * particle.shakeIntensity;
        } else {
          particle.x += particle.vx;
          particle.y += particle.vy;
        }
        
        particle.vy += particle.gravity;
        particle.life -= particle.decay;
        particle.rotation += particle.rotationSpeed;
        
        // Dramatic particles have special behaviors
        if (particle.isDramatic) {
          // Dramatic particles might explode outward more
          if (Math.random() < 0.03) {
            particle.vx *= 1.2;
            particle.vy *= 1.2;
          }
        }
        
        // Bounce off canvas edges
        const tileSize = window.tileSize || 20;
        const canvasWidth = mapWidth * tileSize;
        const canvasHeight = mapHeight * tileSize;
        
        if (particle.x <= 0 || particle.x >= canvasWidth) {
          particle.vx *= -particle.bounce;
          particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
        }
        if (particle.y >= canvasHeight) {
          particle.vy *= -particle.bounce;
          particle.y = canvasHeight;
        }
        
        if (particle.life <= 0) {
          gameOverParticles.splice(i, 1);
        }
      }
    }

    function drawGameOverParticles() {
      gameOverParticles.forEach(particle => {
        ctx.save();
        
        // Calculate opacity with smoke effect
        let opacity = particle.life;
        if (particle.smoke) {
          opacity *= particle.smokeOpacity;
        }
        
        ctx.globalAlpha = opacity;
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation);
        
        if (particle.type === 'emoji') {
          ctx.font = `${particle.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, 0, 0);
        } else if (particle.type === 'skull') {
          drawSkull(ctx, 0, 0, particle.size * 0.4);
        } else if (particle.type === 'explosion') {
          drawExplosion(ctx, 0, 0, particle.size * 0.5);
        } else if (particle.type === 'smoke') {
          drawSmoke(ctx, 0, 0, particle.size * 0.6);
        }
        
        ctx.restore();
      });
    }

    function drawSkull(ctx, x, y, size) {
      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      
      // Skull shape
      ctx.beginPath();
      ctx.arc(x, y, size, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      
      // Eye sockets
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(x - size * 0.3, y - size * 0.2, size * 0.15, 0, 2 * Math.PI);
      ctx.arc(x + size * 0.3, y - size * 0.2, size * 0.15, 0, 2 * Math.PI);
      ctx.fill();
      
      // Nose
      ctx.beginPath();
      ctx.arc(x, y + size * 0.1, size * 0.1, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawExplosion(ctx, x, y, size) {
      ctx.strokeStyle = '#FF4500';
      ctx.fillStyle = '#FF6347';
      ctx.lineWidth = 3;
      
      // Draw explosion rays
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI) / 4;
        const endX = x + Math.cos(angle) * size;
        const endY = y + Math.sin(angle) * size;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
      
      // Center explosion
      ctx.beginPath();
      ctx.arc(x, y, size * 0.3, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawSmoke(ctx, x, y, size) {
      ctx.fillStyle = '#696969';
      ctx.globalAlpha = 0.6;
      
      // Draw smoke cloud
      ctx.beginPath();
      ctx.arc(x, y, size * 0.8, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(x + size * 0.3, y - size * 0.2, size * 0.6, 0, 2 * Math.PI);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(x - size * 0.2, y + size * 0.3, size * 0.5, 0, 2 * Math.PI);
      ctx.fill();
    }

    // Weapon system functions
    function useFireBlast() {
      if (fireBlastCooldown > 0) return;
      
      // Play fire blast sound
      if (fireSound) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createBufferSource();
          source.buffer = fireSound;
          source.connect(audioContext.destination);
          source.start();
        } catch (e) {
          console.log('Fire sound play failed:', e);
        }
      }
      
      fireBlastCooldown = FIRE_BLAST_COOLDOWN;
      createFireBlastEffect();
      
      // Find the first ghost in line of sight
      const hitGhost = findFirstGhostInLineOfSight(FIRE_BLAST_RANGE);
      
      if (hitGhost) {
        // Apply fire damage to only the first ghost hit
        if (!burningGhosts.includes(hitGhost)) {
          burningGhosts.push(hitGhost);
          createFireDamageEffect(hitGhost);
        }
      }
      
      updateWeaponUI();
    }

    function useFreezeWind() {
      if (freezeWindCooldown > 0) return;
      
      // Play freeze wind sound
      if (freezeSound) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createBufferSource();
          source.buffer = freezeSound;
          source.connect(audioContext.destination);
          source.start();
        } catch (e) {
          console.log('Freeze sound play failed:', e);
        }
      }
      
      freezeWindCooldown = FREEZE_WIND_COOLDOWN;
      createFreezeWindEffect();
      
      // Find the first ghost in line of sight
      const hitGhost = findFirstGhostInLineOfSight(FREEZE_WIND_RANGE);
      
      if (hitGhost) {
        // Freeze only the first ghost hit
        if (!frozenGhosts.includes(hitGhost)) {
          createFreezeEffect(hitGhost);
        }
      }
      
      updateWeaponUI();
    }

    function createFireBlastEffect() {
      const tileSize = window.tileSize || 20;
      const startX = pacman.x * tileSize + tileSize / 2;
      const startY = pacman.y * tileSize + tileSize / 2;
      
      // Fire emojis for variety
      const fireEmojis = ['🔥', '💥', '⚡', '🔥', '💥'];
      
      // Create fire blast projectile - travels in straight line
      const direction = pacman.direction;
      let vx = 0, vy = 0;
      const speed = 4; // Consistent speed
      
      switch (direction) {
        case 'right':
          vx = speed;
          vy = 0;
          break;
        case 'left':
          vx = -speed;
          vy = 0;
          break;
        case 'up':
          vx = 0;
          vy = -speed;
          break;
        case 'down':
          vx = 0;
          vy = speed;
          break;
      }
      
      // Create multiple particles in a line formation
      for (let i = 0; i < 8; i++) {
        const offset = i * 8; // Space particles along the line
        let offsetX = 0, offsetY = 0;
        
        switch (direction) {
          case 'right':
            offsetX = -offset;
            break;
          case 'left':
            offsetX = offset;
            break;
          case 'up':
            offsetY = offset;
            break;
          case 'down':
            offsetY = -offset;
            break;
        }
        
        weaponParticles.push({
          x: startX + offsetX,
          y: startY + offsetY,
          vx: vx,
          vy: vy,
          life: 1.0,
          decay: 0.008, // Slower decay so particles last longer
          color: '#FF4500',
          size: 14 + Math.random() * 6,
          type: 'fire',
          direction: direction,
          emoji: fireEmojis[Math.floor(Math.random() * fireEmojis.length)]
        });
      }
    }

    // Find the first ghost in line of sight along the weapon's path
    function findFirstGhostInLineOfSight(range) {
      const direction = pacman.direction;
      let dx = 0, dy = 0;
      
      // Set direction vector
      switch (direction) {
        case 'right': dx = 1; break;
        case 'left': dx = -1; break;
        case 'up': dy = -1; break;
        case 'down': dy = 1; break;
      }
      
      // Check each tile along the path
      for (let distance = 1; distance <= range; distance++) {
        const checkX = pacman.x + dx * distance;
        const checkY = pacman.y + dy * distance;
        
        // Check bounds
        if (checkX < 0 || checkX >= mapWidth || checkY < 0 || checkY >= mapHeight) {
          break; // Out of bounds
        }
        
        // Check if we hit a wall
        if (map[checkY] && map[checkY][checkX] === 1) {
          break; // Hit a wall
        }
        
        // Check if there's a ghost at this position
        const ghostAtPosition = ghosts.find(ghost => ghost.x === checkX && ghost.y === checkY);
        if (ghostAtPosition) {
          return ghostAtPosition; // Found the first ghost in line of sight
        }
      }
      
      return null; // No ghost found in line of sight
    }

    function createFreezeWindEffect() {
      const tileSize = window.tileSize || 20;
      const startX = pacman.x * tileSize + tileSize / 2;
      const startY = pacman.y * tileSize + tileSize / 2;
      
      // Ice and snow emojis for variety
      const iceEmojis = ['❄️', '🌨️', '💨', '❄️', '🌨️', '💨'];
      
      // Create freeze wind projectile - travels in straight line
      const direction = pacman.direction;
      let vx = 0, vy = 0;
      const speed = 3; // Slightly slower than fire
      
      switch (direction) {
        case 'right':
          vx = speed;
          vy = 0;
          break;
        case 'left':
          vx = -speed;
          vy = 0;
          break;
        case 'up':
          vx = 0;
          vy = -speed;
          break;
        case 'down':
          vx = 0;
          vy = speed;
          break;
      }
      
      // Create multiple particles in a line formation
      for (let i = 0; i < 6; i++) {
        const offset = i * 6; // Space particles along the line
        let offsetX = 0, offsetY = 0;
        
        switch (direction) {
          case 'right':
            offsetX = -offset;
            break;
          case 'left':
            offsetX = offset;
            break;
          case 'up':
            offsetY = offset;
            break;
          case 'down':
            offsetY = -offset;
            break;
        }
        
        weaponParticles.push({
          x: startX + offsetX,
          y: startY + offsetY,
          vx: vx,
          vy: vy,
          life: 1.0,
          decay: 0.006, // Much slower decay so particles last longer
          color: '#00BFFF',
          size: 12 + Math.random() * 4,
          type: 'ice',
          direction: direction,
          emoji: iceEmojis[Math.floor(Math.random() * iceEmojis.length)]
        });
      }
    }

    function createFireDamageEffect(ghost) {
      const tileSize = window.tileSize || 20;
      const ghostX = ghost.x * tileSize + tileSize / 2;
      const ghostY = ghost.y * tileSize + tileSize / 2;
      
      // Play fire hit sound
      if (fireHitSound) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createBufferSource();
          source.buffer = fireHitSound;
          source.connect(audioContext.destination);
          source.start();
        } catch (e) {
          console.log('Fire hit sound play failed:', e);
        }
      }
      
      // Stop ghost movement immediately
      ghost.isBurning = true;
      ghost.burnStartTime = Date.now();
      
      // Dramatic fire engulfment effect
      const engulfEmojis = ['🔥', '💥', '🔥', '💥', '🔥', '💥'];
      
      // Create intense fire engulfment particles
      for (let i = 0; i < 15; i++) {
        weaponParticles.push({
          x: ghostX + (Math.random() - 0.5) * 30,
          y: ghostY + (Math.random() - 0.5) * 30,
          vx: (Math.random() - 0.5) * 3,
          vy: -3 - Math.random() * 3,
          life: 1.0,
          decay: 0.02,
          color: '#FF4500',
          size: 12 + Math.random() * 8,
          type: 'engulf',
          emoji: engulfEmojis[Math.floor(Math.random() * engulfEmojis.length)]
        });
      }
      
      // Remove ghost after dramatic burning effect and schedule respawn
      setTimeout(() => {
        const index = burningGhosts.indexOf(ghost);
        if (index > -1) {
          burningGhosts.splice(index, 1);
        }
        
        const ghostIndex = ghosts.indexOf(ghost);
        if (ghostIndex > -1) {
          // Store ghost data for respawn
          const ghostData = {
            color: ghost.color,
            name: ghost.name
          };
          
          // Remove ghost from current position
          ghosts.splice(ghostIndex, 1);
          console.log(`Ghost ${ghost.name} removed. Total ghosts: ${ghosts.length}`);
          
          // Respawn ghost after 3 seconds
          setTimeout(() => {
            respawnGhost(ghostData);
          }, 3000);
        }
      }, 1500); // Increased burn time for more dramatic effect
    }

    function createFreezeEffect(ghost) {
      console.log('Freezing ghost:', ghost.name, 'at position:', ghost.x, ghost.y);
      
      const tileSize = window.tileSize || 20;
      const ghostX = ghost.x * tileSize + tileSize / 2;
      const ghostY = ghost.y * tileSize + tileSize / 2;
      
      // Freeze effect emojis
      const freezeEmojis = ['❄️', '🧊', '❄️', '🧊', '💎', '❄️'];
      
      // Create dramatic freeze effect particles
      for (let i = 0; i < 12; i++) {
        weaponParticles.push({
          x: ghostX + (Math.random() - 0.5) * 20,
          y: ghostY + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 2,
          vy: -2 - Math.random() * 2,
          life: 1.0,
          decay: 0.02,
          color: '#87CEEB',
          size: 10 + Math.random() * 5,
          type: 'freeze',
          emoji: freezeEmojis[Math.floor(Math.random() * freezeEmojis.length)]
        });
      }
      
      // Add to frozen ghosts list
      if (!frozenGhosts.includes(ghost)) {
        frozenGhosts.push(ghost);
        console.log('Ghost added to frozen list. Total frozen:', frozenGhosts.length);
      }
      
      // Remove freeze effect after 2 seconds
      setTimeout(() => {
        const index = frozenGhosts.indexOf(ghost);
        if (index > -1) {
          frozenGhosts.splice(index, 1);
          console.log('Ghost unfrozen:', ghost.name);
        }
      }, 2000);
    }

    function updateWeaponParticles() {
      const tileSize = window.tileSize || 20;
      
      for (let i = weaponParticles.length - 1; i >= 0; i--) {
        const particle = weaponParticles[i];
        
        // Calculate new position
        const newX = particle.x + particle.vx;
        const newY = particle.y + particle.vy;
        
        // Check if particle would hit a wall
        const gridX = Math.floor(newX / tileSize);
        const gridY = Math.floor(newY / tileSize);
        
        // Check bounds and wall collision
        if (gridX < 0 || gridX >= mapWidth || gridY < 0 || gridY >= mapHeight || 
            (map[gridY] && map[gridY][gridX] === 1)) {
          // Hit wall or out of bounds - remove particle
          weaponParticles.splice(i, 1);
          continue;
        }
        
        // Update position
        particle.x = newX;
        particle.y = newY;
        particle.life -= particle.decay;
        
        // Remove particle if life is depleted
        if (particle.life <= 0) {
          weaponParticles.splice(i, 1);
        }
      }
    }

    function drawWeaponParticles() {
      weaponParticles.forEach(particle => {
        ctx.save();
        ctx.globalAlpha = particle.life;
        
        if (particle.type === 'fire') {
          // Draw fire emoji particle
          ctx.font = `${particle.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, particle.x, particle.y);
          
          // Add glow effect
          ctx.shadowColor = '#FF4500';
          ctx.shadowBlur = 15;
          ctx.fillText(particle.emoji, particle.x, particle.y);
        } else if (particle.type === 'ice') {
          // Draw ice emoji particle
          ctx.font = `${particle.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, particle.x, particle.y);
          
          // Add sparkle effect
          ctx.shadowColor = '#00BFFF';
          ctx.shadowBlur = 8;
          ctx.fillText(particle.emoji, particle.x, particle.y);
        } else if (particle.type === 'damage') {
          // Draw damage emoji particle
          ctx.font = `${particle.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, particle.x, particle.y);
        } else if (particle.type === 'engulf') {
          // Draw dramatic engulfment emoji particle
          ctx.font = `${particle.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, particle.x, particle.y);
          
          // Add intense glow effect
          ctx.shadowColor = '#FF4500';
          ctx.shadowBlur = 15;
          ctx.fillText(particle.emoji, particle.x, particle.y);
        } else if (particle.type === 'freeze') {
          // Draw freeze emoji particle
          ctx.font = `${particle.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(particle.emoji, particle.x, particle.y);
          
          // Add ice glow effect
          ctx.shadowColor = '#87CEEB';
          ctx.shadowBlur = 6;
          ctx.fillText(particle.emoji, particle.x, particle.y);
        }
        
        ctx.restore();
      });
    }

    function updateWeaponUI() {
      const fireBtn = document.querySelector('.weapon-btn.fire-blast');
      const freezeBtn = document.querySelector('.weapon-btn.freeze-wind');
      
      if (fireBlastCooldown > 0) {
        fireBtn.disabled = true;
        const progress = 1 - (fireBlastCooldown / FIRE_BLAST_COOLDOWN);
        const degrees = progress * 360;
        const progressElement = fireBtn.querySelector('.cooldown-progress');
        progressElement.style.background = `conic-gradient(from 0deg, rgba(255, 69, 0, 0.4) 0deg, rgba(255, 69, 0, 0.4) ${degrees}deg, transparent ${degrees}deg, transparent 360deg)`;
        
        const seconds = Math.ceil(fireBlastCooldown / 1000);
        fireBtn.querySelector('.cooldown-text').textContent = `${seconds}s`;
      } else {
        fireBtn.disabled = false;
        const progressElement = fireBtn.querySelector('.cooldown-progress');
        progressElement.style.background = 'conic-gradient(from 0deg, transparent 0deg, transparent 360deg)';
        fireBtn.querySelector('.cooldown-text').textContent = 'Ready';
      }
      
      if (freezeWindCooldown > 0) {
        freezeBtn.disabled = true;
        const progress = 1 - (freezeWindCooldown / FREEZE_WIND_COOLDOWN);
        const degrees = progress * 360;
        const progressElement = freezeBtn.querySelector('.cooldown-progress');
        progressElement.style.background = `conic-gradient(from 0deg, rgba(0, 191, 255, 0.4) 0deg, rgba(0, 191, 255, 0.4) ${degrees}deg, transparent ${degrees}deg, transparent 360deg)`;
        
        const seconds = Math.ceil(freezeWindCooldown / 1000);
        freezeBtn.querySelector('.cooldown-text').textContent = `${seconds}s`;
      } else {
        freezeBtn.disabled = false;
        const progressElement = freezeBtn.querySelector('.cooldown-progress');
        progressElement.style.background = 'conic-gradient(from 0deg, transparent 0deg, transparent 360deg)';
        freezeBtn.querySelector('.cooldown-text').textContent = 'Ready';
      }
    }

    function updateWeaponCooldowns() {
      const currentTime = Date.now();
      const elapsedTime = currentTime - lastWeaponUpdateTime;
      lastWeaponUpdateTime = currentTime;
      
      if (fireBlastCooldown > 0) {
        fireBlastCooldown -= elapsedTime;
        if (fireBlastCooldown < 0) fireBlastCooldown = 0;
      }
      
      if (freezeWindCooldown > 0) {
        freezeWindCooldown -= elapsedTime;
        if (freezeWindCooldown < 0) freezeWindCooldown = 0;
      }
      
      // Update UI more frequently for smoother animation
      updateWeaponUI();
    }

    function respawnGhost(ghostData) {
      // Find a safe, distant respawn location
      const respawnLocation = findSafeRespawnLocation();
      
      if (respawnLocation) {
        // Create new ghost with same properties
        const newGhost = {
          x: respawnLocation.x,
          y: respawnLocation.y,
          color: ghostData.color,
          name: ghostData.name
        };
        
        ghosts.push(newGhost);
        console.log(`Ghost ${ghostData.name} respawned at (${respawnLocation.x}, ${respawnLocation.y}) - Distance from Pacman: ${respawnLocation.distance}`);
        console.log(`Total ghosts after respawn: ${ghosts.length}`);
      } else {
        console.log(`Failed to find safe respawn location for ${ghostData.name}`);
      }
    }

    function findSafeRespawnLocation() {
      const minDistance = 8; // Minimum distance from Pacman
      const maxAttempts = 100;
      let attempts = 0;
      
      // Get all valid respawn positions
      const validPositions = [];
      
      for (let y = 1; y < mapHeight - 1; y++) {
        for (let x = 1; x < mapWidth - 1; x++) {
          // Check if position is valid (empty and not occupied)
          if (map[y][x] === 0 && 
              !ghosts.some(g => g.x === x && g.y === y) &&
              (x !== pacman.x || y !== pacman.y)) {
            
            // Calculate distance from Pacman
            const distance = Math.abs(x - pacman.x) + Math.abs(y - pacman.y);
            
            if (distance >= minDistance) {
              validPositions.push({x, y, distance});
            }
          }
        }
      }
      
      // Sort by distance (farthest first) and add some randomness
      validPositions.sort((a, b) => {
        // Prefer farther positions but add some randomness
        const distanceWeight = 0.7;
        const randomWeight = 0.3;
        
        const distanceScore = (b.distance - a.distance) * distanceWeight;
        const randomScore = (Math.random() - 0.5) * randomWeight;
        
        return distanceScore + randomScore;
      });
      
      // Return the best position (farthest with some randomness)
      return validPositions.length > 0 ? validPositions[0] : null;
    }

    function draw() {
      const tileSize = window.tileSize || 20;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          if (map[y][x] === 1) {
            ctx.fillStyle = '#0033cc';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
          if (map[y][x] === 2) {
            // Draw apple emoji as the exit
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            
            ctx.font = `${tileSize - 4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🍎', centerX, centerY);
          }
          

          if (pelletMap[y][x] === 1) {
            ctx.beginPath();
            ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 3, 0, 2 * Math.PI);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
          }
        }
      }
      
      // Draw ghosts
      for (const ghost of ghosts) {
        const isFrozen = frozenGhosts.includes(ghost);
        const isBurning = burningGhosts.includes(ghost);
        
        ctx.save();
        
        // Apply freeze effect
        if (isFrozen) {
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = '#87CEEB';
          ctx.beginPath();
          ctx.arc(
            ghost.x * tileSize + tileSize / 2,
            ghost.y * tileSize + tileSize / 2,
            tileSize / 2 + 2,
            0, 2 * Math.PI
          );
          ctx.fill();
        }
        
        // Apply dramatic burn effect
        if (isBurning) {
          ctx.globalAlpha = 0.6;
          ctx.shadowColor = '#FF4500';
          ctx.shadowBlur = 20;
          
          // Draw intense fire aura around ghost
          ctx.fillStyle = '#FF4500';
          ctx.beginPath();
          ctx.arc(
            ghost.x * tileSize + tileSize / 2,
            ghost.y * tileSize + tileSize / 2,
            tileSize / 2 + 4,
            0, 2 * Math.PI
          );
          ctx.fill();
        }
        
        ctx.beginPath();
        ctx.arc(
          ghost.x * tileSize + tileSize / 2,
          ghost.y * tileSize + tileSize / 2,
          tileSize / 2 - 3,
          Math.PI, 0, false
        );
        ctx.lineTo(ghost.x * tileSize + tileSize - 3, ghost.y * tileSize + tileSize - 3);
        ctx.lineTo(ghost.x * tileSize + 3, ghost.y * tileSize + tileSize - 3);
        ctx.closePath();
        ctx.fillStyle = ghost.color;
        ctx.fill();
        
        // Eyes
        ctx.beginPath();
        ctx.arc(ghost.x * tileSize + tileSize/2 - 4, ghost.y * tileSize + tileSize/2 - 1, 2, 0, 2 * Math.PI);
        ctx.arc(ghost.x * tileSize + tileSize/2 + 4, ghost.y * tileSize + tileSize/2 - 1, 2, 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(ghost.x * tileSize + tileSize/2 - 4, ghost.y * tileSize + tileSize/2 - 1, 0.8, 0, 2 * Math.PI);
        ctx.arc(ghost.x * tileSize + tileSize/2 + 4, ghost.y * tileSize + tileSize/2 - 1, 0.8, 0, 2 * Math.PI);
        ctx.fillStyle = '#222';
        ctx.fill();
        
        // Draw ghost name above (smaller for portrait mode)
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.fillStyle = ghost.color;
        ctx.fillText(ghost.name, ghost.x * tileSize + tileSize / 2, ghost.y * tileSize - 2);
        
        // Add status effects to name
        if (isFrozen) {
          ctx.fillStyle = '#87CEEB';
          ctx.fillText('❄️', ghost.x * tileSize + tileSize / 2, ghost.y * tileSize - 12);
        }
        if (isBurning) {
          ctx.fillStyle = '#FF4500';
          ctx.fillText('🔥', ghost.x * tileSize + tileSize / 2, ghost.y * tileSize - 12);
        }
        
        ctx.restore();
      }
      
      // Draw Pacman with directional mouth
      ctx.beginPath();
      const centerX = pacman.x * tileSize + tileSize / 2;
      const centerY = pacman.y * tileSize + tileSize / 2;
      const radius = tileSize / 2 - 1;
      
      let startAngle, endAngle;
      switch (pacman.direction) {
        case 'right':
          startAngle = 0.25 * Math.PI;
          endAngle = 1.75 * Math.PI;
          break;
        case 'left':
          startAngle = 1.25 * Math.PI;
          endAngle = 0.75 * Math.PI;
          break;
        case 'up':
          startAngle = 1.75 * Math.PI;
          endAngle = 1.25 * Math.PI;
          break;
        case 'down':
          startAngle = 0.75 * Math.PI;
          endAngle = 0.25 * Math.PI;
          break;
        default:
          startAngle = 0.25 * Math.PI;
          endAngle = 1.75 * Math.PI;
      }
      
      ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
      ctx.lineTo(centerX, centerY);
      ctx.closePath();
      ctx.fillStyle = 'yellow';
      ctx.fill();
      
      // Draw celebration particles if celebrating
      if (isCelebrating) {
        drawCelebrationParticles();
      }
      
      // Draw weapon particles
      drawWeaponParticles();
      
      // Draw game over particles if animating
      if (isGameOverAnimating) {
        drawGameOverParticles();
      }
    }

    function moveGhosts() {
      for (const ghost of ghosts) {
        // Skip frozen ghosts
        if (frozenGhosts.includes(ghost)) {
          console.log('Skipping frozen ghost:', ghost.name);
          continue;
        }
        
        // Skip burning ghosts - they should not move
        if (ghost.isBurning) {
          continue;
        }
        
        // Try random directions until a valid move is found
        const dirs = [ [0, -1], [0, 1], [-1, 0], [1, 0] ];
        for (let i = dirs.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
        }
        for (const [dx, dy] of dirs) {
          const nx = ghost.x + dx;
          const ny = ghost.y + dy;
          if (map[ny] && map[ny][nx] === 0 && !ghosts.some(g => g !== ghost && g.x === nx && g.y === ny)) {
            ghost.x = nx;
            ghost.y = ny;
            break;
          }
        }
      }
      // Check collision with Pac-Man
      for (const ghost of ghosts) {
        if (ghost.x === pacman.x && ghost.y === pacman.y) {
          playerLives--;
          if (playerLives <= 0) {
            // Play game over sound
            if (gameOverSound) {
              try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createBufferSource();
                source.buffer = gameOverSound;
                source.connect(audioContext.destination);
                source.start();
              } catch (e) {
                console.log('Game over sound play failed:', e);
              }
            }
            
            // Start game over animation
            isGameOverAnimating = true;
            gameOverParticles = [];
            createGameOverParticles(pacman.x * (window.tileSize || 20), pacman.y * (window.tileSize || 20));
            
            // Start game over animation loop
            const gameOverInterval = setInterval(() => {
              updateGameOverParticles();
              draw();
              
              // Stop animation after particles are gone
              if (gameOverParticles.length === 0) {
                clearInterval(gameOverInterval);
                isGameOverAnimating = false;
              }
            }, 50);
            
            message.innerText = 'Game Over!';
            clearInterval(ghostMoveInterval);
            if (weaponUpdateInterval) clearInterval(weaponUpdateInterval);
            setTimeout(() => {
              currentLevel = 1;
              resetGame();
            }, 2000);
            return;
          } else {
            // Start mini game over animation for losing a life
            isGameOverAnimating = true;
            gameOverParticles = [];
            createGameOverParticles(pacman.x * (window.tileSize || 20), pacman.y * (window.tileSize || 20));
            
            // Start mini animation loop
            const miniGameOverInterval = setInterval(() => {
              updateGameOverParticles();
              draw();
              
              // Stop animation after particles are gone
              if (gameOverParticles.length === 0) {
                clearInterval(miniGameOverInterval);
                isGameOverAnimating = false;
              }
            }, 50);
            
            document.getElementById('livesDisplay').innerText = `Lives: ${playerLives}`;
            message.innerText = `Lost a life! Lives remaining: ${playerLives}`;
            // Reset Pacman position and direction
            pacman.x = 1;
            pacman.y = 1;
            pacman.direction = 'right';
            draw();
            return;
          }
        }
      }
      draw();
    }

    function tryMove(dx, dy) {
      const nx = pacman.x + dx;
      const ny = pacman.y + dy;
      if (map[ny] && (map[ny][nx] === 0 || map[ny][nx] === 2)) {
        pacman.x = nx;
        pacman.y = ny;
        
        // Update Pacman's direction based on movement
        if (dx > 0) pacman.direction = 'right';
        else if (dx < 0) pacman.direction = 'left';
        else if (dy > 0) pacman.direction = 'down';
        else if (dy < 0) pacman.direction = 'up';
        
        // Check if Pacman reached the door (win condition)
        if (map[ny][nx] === 2) {
          // Start celebration animation
          isCelebrating = true;
          celebrationParticles = [];
          createCelebrationParticles(pacman.x * (window.tileSize || 20), pacman.y * (window.tileSize || 20));
          
          // Start celebration animation loop
          const celebrationInterval = setInterval(() => {
            updateCelebrationParticles();
            draw();
            
            // Stop celebration after 3 seconds
            if (celebrationParticles.length === 0) {
              clearInterval(celebrationInterval);
              isCelebrating = false;
            }
          }, 50);
          
          // Calculate score for this level
          const timeElapsed = Date.now() - levelStartTime;
          const { lives: maxLives } = getLevelParameters(currentLevel);
          currentScore = calculateScore(timeElapsed, pelletsCollected, totalPelletsInLevel, playerLives, maxLives);
          totalScore += currentScore;
          completedLevels++;
          averageScore = Math.round(totalScore / completedLevels);
          
          if (currentLevel >= 100) {
            message.innerText = `🎉 Congratulations! You completed all 100 levels! Final Total: ${totalScore}, Average: ${averageScore} 🎉`;
            clearInterval(ghostMoveInterval);
            if (weaponUpdateInterval) clearInterval(weaponUpdateInterval);
            setTimeout(() => {
              currentLevel = 1;
              totalScore = 0;
              completedLevels = 0;
              averageScore = 0;
              resetGame();
            }, 3000);
            return;
          } else {
            currentLevel++;
            message.innerText = `🎉 Level ${currentLevel - 1} Complete! Score: ${currentScore}/100 (Total: ${totalScore}, Avg: ${averageScore}) 🎉`;
            clearInterval(ghostMoveInterval);
            if (weaponUpdateInterval) clearInterval(weaponUpdateInterval);
            setTimeout(resetGame, 2000);
            return;
          }
        }
        
        if (pelletMap[ny][nx] === 1) {
          pelletMap[ny][nx] = 0;
          pelletsLeft--;
          pelletsCollected++;
          // Play waka-waka sound when eating a pellet
          try {
            wakaSound.currentTime = 0;
            wakaSound.play();
          } catch (e) {}
        }
                      // Check collision with ghosts after Pac-Man moves
      for (const ghost of ghosts) {
        if (ghost.x === pacman.x && ghost.y === pacman.y) {
            playerLives--;
            if (playerLives <= 0) {
              // Play game over sound
              if (gameOverSound) {
                try {
                  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                  const source = audioContext.createBufferSource();
                  source.buffer = gameOverSound;
                  source.connect(audioContext.destination);
                  source.start();
                } catch (e) {
                  console.log('Game over sound play failed:', e);
                }
              }
              
              // Start game over animation
              isGameOverAnimating = true;
              gameOverParticles = [];
              createGameOverParticles(pacman.x * (window.tileSize || 20), pacman.y * (window.tileSize || 20));
              
              // Start game over animation loop
              const gameOverInterval = setInterval(() => {
                updateGameOverParticles();
                draw();
                
                // Stop animation after particles are gone
                if (gameOverParticles.length === 0) {
                  clearInterval(gameOverInterval);
                  isGameOverAnimating = false;
                }
              }, 50);
              
              message.innerText = 'Game Over!';
              clearInterval(ghostMoveInterval);
              if (weaponUpdateInterval) clearInterval(weaponUpdateInterval);
              setTimeout(() => {
                currentLevel = 1;
                resetGame();
              }, 2000);
              return;
            } else {
              // Start mini game over animation for losing a life
              isGameOverAnimating = true;
              gameOverParticles = [];
              createGameOverParticles(pacman.x * (window.tileSize || 20), pacman.y * (window.tileSize || 20));
              
              // Start mini animation loop
              const miniGameOverInterval = setInterval(() => {
                updateGameOverParticles();
                draw();
                
                // Stop animation after particles are gone
                if (gameOverParticles.length === 0) {
                  clearInterval(miniGameOverInterval);
                  isGameOverAnimating = false;
                }
              }, 50);
              
              document.getElementById('livesDisplay').innerText = `Lives: ${playerLives}`;
              message.innerText = `Lost a life! Lives remaining: ${playerLives}`;
              // Reset Pacman position and direction
              pacman.x = 1;
              pacman.y = 1;
              pacman.direction = 'right';
              draw();
              return;
            }
          }
        }
      }
      draw();
    }

    // Keyboard controls
    document.addEventListener('keydown', e => {
      switch (e.key) {
        case 'ArrowUp': tryMove(0, -1); break;
        case 'ArrowDown': tryMove(0, 1); break;
        case 'ArrowLeft': tryMove(-1, 0); break;
        case 'ArrowRight': tryMove(1, 0); break;
        case ' ': useFireBlast(); break; // Spacebar for fire blast
        case 'f': useFreezeWind(); break; // F key for freeze wind
      }
    });
    
    // Prevent default touch behaviors that might interfere with game
    document.addEventListener('touchstart', (e) => {
      if (e.target.tagName !== 'BUTTON' && !e.target.closest('.hamburger-menu') && !e.target.closest('.menu-overlay')) {
        e.preventDefault();
      }
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
      if (e.target.tagName !== 'BUTTON' && !e.target.closest('.hamburger-menu') && !e.target.closest('.menu-overlay')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Mobile touch controls with iOS support
    document.querySelectorAll('.control-btn').forEach(btn => {
      let touchStartTime = 0;
      let touchEndTime = 0;
      
      // Handle touch events for iOS
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchStartTime = Date.now();
        btn.style.transform = 'scale(0.95)';
        btn.style.background = 'rgba(255, 215, 0, 0.5)';
      });
      
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchEndTime = Date.now();
        
        // Only trigger if it's a quick tap (not a long press)
        if (touchEndTime - touchStartTime < 300) {
          const direction = btn.dataset.direction;
          switch (direction) {
            case 'up': tryMove(0, -1); break;
            case 'down': tryMove(0, 1); break;
            case 'left': tryMove(-1, 0); break;
            case 'right': tryMove(1, 0); break;
          }
        }
        
        // Reset button appearance
        btn.style.transform = 'scale(1)';
        btn.style.background = 'rgba(255, 215, 0, 0.2)';
      });
      
      // Handle mouse clicks for desktop
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        
        const direction = btn.dataset.direction;
        switch (direction) {
          case 'up': tryMove(0, -1); break;
          case 'down': tryMove(0, 1); break;
          case 'left': tryMove(-1, 0); break;
          case 'right': tryMove(1, 0); break;
        }
      });
      
      // Prevent context menu on long press
      btn.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
    });

    // Weapon button controls
    document.querySelectorAll('.weapon-btn').forEach(btn => {
      let touchStartTime = 0;
      let touchEndTime = 0;
      
      // Handle touch events for iOS
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (btn.disabled) return;
        
        touchStartTime = Date.now();
        btn.style.transform = 'scale(0.95)';
      });
      
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (btn.disabled) return;
        
        touchEndTime = Date.now();
        
        // Only trigger if it's a quick tap (not a long press)
        if (touchEndTime - touchStartTime < 300) {
          const weapon = btn.dataset.weapon;
          switch (weapon) {
            case 'fire': useFireBlast(); break;
            case 'freeze': useFreezeWind(); break;
          }
        }
        
        // Reset button appearance
        btn.style.transform = 'scale(1)';
      });
      
      // Handle mouse clicks for desktop
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (btn.disabled) return;
        
        const weapon = btn.dataset.weapon;
        switch (weapon) {
          case 'fire': useFireBlast(); break;
          case 'freeze': useFreezeWind(); break;
        }
      });
      
      // Prevent context menu on long press
      btn.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
    });

    // Initialize sound effects
    function initSounds() {
      try {
        // Create Web Audio Context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Fire blast sound - dramatic whoosh with explosion
        fireSound = createFireBlastSound(audioContext);
        
        // Fire hit sound - explosion effect
        fireHitSound = createFireHitSound(audioContext);
        
        // Freeze wind sound - icy whoosh
        freezeSound = createFreezeWindSound(audioContext);
        
        // Game over sound - dramatic failure
        gameOverSound = createGameOverSound(audioContext);
        
      } catch (error) {
        console.log('Audio not supported, continuing without sound effects');
      }
    }
    
    // Create fire blast sound using Web Audio API
    function createFireBlastSound(audioContext) {
      const duration = 0.8;
      const sampleRate = audioContext.sampleRate;
      const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < buffer.length; i++) {
        const t = i / sampleRate;
        const frequency = 200 + 800 * Math.exp(-t * 3); // Descending frequency
        const amplitude = Math.exp(-t * 2) * 0.3; // Decay envelope
        const noise = (Math.random() - 0.5) * 0.5; // Add some noise
        const wave = Math.sin(2 * Math.PI * frequency * t) + noise;
        data[i] = wave * amplitude;
      }
      
      return buffer;
    }
    
    // Create fire hit sound using Web Audio API
    function createFireHitSound(audioContext) {
      const duration = 0.6;
      const sampleRate = audioContext.sampleRate;
      const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < buffer.length; i++) {
        const t = i / sampleRate;
        const frequency = 150 + 600 * Math.exp(-t * 4); // Lower, faster decay
        const amplitude = Math.exp(-t * 3) * 0.4; // Sharp decay
        const noise = (Math.random() - 0.5) * 0.8; // More noise for explosion
        const wave = Math.sin(2 * Math.PI * frequency * t) + noise;
        data[i] = wave * amplitude;
      }
      
      return buffer;
    }
    
         // Create freeze wind sound using Web Audio API
     function createFreezeWindSound(audioContext) {
       const duration = 1.0;
       const sampleRate = audioContext.sampleRate;
       const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
       const data = buffer.getChannelData(0);
       
       for (let i = 0; i < buffer.length; i++) {
         const t = i / sampleRate;
         const frequency = 300 + 200 * Math.sin(t * 10); // Oscillating frequency
         const amplitude = Math.exp(-t * 1.5) * 0.25; // Gentle decay
         const noise = (Math.random() - 0.5) * 0.3; // Subtle noise
         const wave = Math.sin(2 * Math.PI * frequency * t) + noise;
         data[i] = wave * amplitude;
       }
       
       return buffer;
     }
     
     // Create game over sound using Web Audio API
     function createGameOverSound(audioContext) {
       const duration = 2.0;
       const sampleRate = audioContext.sampleRate;
       const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
       const data = buffer.getChannelData(0);
       
       for (let i = 0; i < buffer.length; i++) {
         const t = i / sampleRate;
         
         // Create a dramatic descending tone with multiple harmonics
         const baseFreq = 400 * Math.exp(-t * 1.5); // Descending base frequency
         const harmonic1 = 200 * Math.exp(-t * 2); // Lower harmonic
         const harmonic2 = 600 * Math.exp(-t * 1.2); // Higher harmonic
         
         // Combine harmonics with different phases
         const wave1 = Math.sin(2 * Math.PI * baseFreq * t);
         const wave2 = Math.sin(2 * Math.PI * harmonic1 * t + Math.PI / 4);
         const wave3 = Math.sin(2 * Math.PI * harmonic2 * t + Math.PI / 2);
         
         // Add dramatic noise for impact
         const noise = (Math.random() - 0.5) * 0.4;
         
         // Create dramatic envelope with multiple stages
         let amplitude;
         if (t < 0.3) {
           amplitude = 0.5; // Strong start
         } else if (t < 0.8) {
           amplitude = 0.3 * Math.exp(-(t - 0.3) * 2); // Quick decay
         } else {
           amplitude = 0.1 * Math.exp(-(t - 0.8) * 3); // Final fade
         }
         
         // Combine all elements
         const combined = (wave1 + wave2 * 0.6 + wave3 * 0.4 + noise) * amplitude;
         data[i] = Math.max(-1, Math.min(1, combined)); // Clamp to valid range
       }
       
       return buffer;
     }



    // Initialize sounds and game
    initSounds();
    resetGame();
    
    // PWA Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration);
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }
    
    // PWA Installation Prompt
    let deferredPrompt;
    
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent Chrome 67 and earlier from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later
      deferredPrompt = e;
      
      // Show install button or notification
      showInstallPrompt();
    });
    
    function showInstallPrompt() {
      // You can add a subtle install button or notification here
      console.log('PWA install prompt available');
      
      // Optional: Show a small install notification
      if (document.getElementById('message').textContent === '') {
        document.getElementById('message').textContent = '💡 Tap to install as app';
        document.getElementById('message').style.cursor = 'pointer';
        document.getElementById('message').addEventListener('click', installPWA);
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          if (document.getElementById('message').textContent === '💡 Tap to install as app') {
            document.getElementById('message').textContent = '';
            document.getElementById('message').style.cursor = 'default';
          }
        }, 5000);
      }
    }
    
    function installPWA() {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the install prompt');
          } else {
            console.log('User dismissed the install prompt');
          }
          deferredPrompt = null;
        });
      }
    }
    
    // Handle successful installation
    window.addEventListener('appinstalled', (evt) => {
      console.log('PWA was installed');
      document.getElementById('message').textContent = '🎉 App installed!';
      setTimeout(() => {
        document.getElementById('message').textContent = '';
      }, 3000);
    });
    
    // Hamburger Menu Functionality
    const hamburgerMenu = document.getElementById('hamburgerMenu');
    const menuOverlay = document.getElementById('menuOverlay');
    const closeMenu = document.getElementById('closeMenu');
    
    // Hamburger menu click and touch handling
    hamburgerMenu.addEventListener('click', openMenu);
    hamburgerMenu.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      openMenu();
    });
    
    function openMenu() {
      console.log('Opening menu...');
      console.log('ghostMoveInterval before clear:', ghostMoveInterval);
      console.log('weaponUpdateInterval before clear:', weaponUpdateInterval);
      
      hamburgerMenu.classList.add('active');
      menuOverlay.classList.add('active');
      
      // Pause game when menu is open
      if (ghostMoveInterval) {
        clearInterval(ghostMoveInterval);
        ghostMoveInterval = null;
        console.log('Cleared ghostMoveInterval');
      }
      if (weaponUpdateInterval) {
        clearInterval(weaponUpdateInterval);
        weaponUpdateInterval = null;
        console.log('Cleared weaponUpdateInterval');
      }
    }
    
    // Close menu handling
    closeMenu.addEventListener('click', closeMenuFunction);
    closeMenu.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeMenuFunction();
    });
    
    function closeMenuFunction() {
      console.log('Closing menu...');
      console.log('ghostMoveInterval before restart:', ghostMoveInterval);
      console.log('weaponUpdateInterval before restart:', weaponUpdateInterval);
      
      hamburgerMenu.classList.remove('active');
      menuOverlay.classList.remove('active');
      
      // Always restart intervals if they're null
      if (!ghostMoveInterval) {
        ghostMoveInterval = setInterval(moveGhosts, 350);
        console.log('Restarted ghostMoveInterval:', ghostMoveInterval);
      }
      if (!weaponUpdateInterval) {
        weaponUpdateInterval = setInterval(() => {
          updateWeaponParticles();
          updateWeaponCooldowns();
          draw();
        }, 16);
        console.log('Restarted weaponUpdateInterval:', weaponUpdateInterval);
      }
      
      // Force a redraw to make sure everything is visible
      draw();
    }
    
    // Close menu when clicking outside
    menuOverlay.addEventListener('click', (e) => {
      if (e.target === menuOverlay) {
        closeMenuFunction();
      }
    });
    
    menuOverlay.addEventListener('touchstart', (e) => {
      if (e.target === menuOverlay) {
        e.preventDefault();
        closeMenuFunction();
      }
    });
    
    // Close menu with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && menuOverlay.classList.contains('active')) {
        closeMenuFunction();
      }
    });
  </script>
</body>
</html> 